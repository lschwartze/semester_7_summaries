\documentclass[a4paper, 12pt]{article}

\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath,amssymb}
\usepackage[explicit]{titlesec}
\usepackage{ulem}
\usepackage[onehalfspacing]{setspace}
\usepackage{amsthm}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section] % reset theorem numbering for each chapter

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition} % definition numbers are dependent on theorem numbers
\theoremstyle{lemma}
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

\theoremstyle{example}
\newtheorem{example}[theorem]{Example}

\titleformat{\subsection}
{\small}{\thesubsection}{1em}{\uline{#1}}
\begin{document}
	\begin{titlepage} 
		\title{QuaC Zusammenfassung}
		\clearpage\maketitle
		\thispagestyle{empty}
	\end{titlepage}
	\tableofcontents
	\newpage
	\section{Grundlagen}
	\subsection{Definitionen}
	\begin{definition}
		$|\phi \rangle$ ist ein Spaltenvektor und $\langle \phi |$ ein Spaltenvektor.\\
		$\langle \phi | \psi \rangle = \sum_{i=1}^{n} \phi_i^* \cdot \psi_i$ ist das innere Produkt.\\
		$|0 \rangle = \binom{1}{0}$ und $|1 \rangle = \binom{0}{1}$. Das sind die Basis Vektoren.
	\end{definition}
	Ein Qubit ist ein normierter Vektor der Form $\alpha |0\rangle + \beta |1\rangle$. Auf diesem kann eine Messung durchgeführt werden, sodass das Qubit kollabiert zu 0 mit Wahrscheinlichkeit $\left|\alpha\right|^2$ und mit Wahrscheinlichkeit  $\left|\beta\right|^2$ zu 1.\\
	Ein $n$-Qubit ist ein Vektor der Dimension $2^n$. Das heißt, obiges Beispiel ist ein 1-Qubit und ein 2-Qubit hat vier Einträge. Die Vektoren sind dabei immer normiert. In höher dimensionalen Vektoren kann eine Messung einzelner Bits ausreichen, um das System zum kollabieren zu bringen.\\
	Ein 1-Qubit-Gatter ist eine unitäre $2\times 2$ Matrix $U$. Das heißt, $U^tU = I$, wobei $U^t = (U^T)^*$. Ein Spezialfall ist dabei $$H = \frac{1}{\sqrt{2}}\begin{pmatrix}
		1 & 1\\
		1 & -1
	\end{pmatrix}$$
	Die Transformation eines Qubits $\phi$ mit $H$ ist dabei einfach $H\cdot \phi$. So ist zum Beispiel $$H(|0\rangle) = \frac{1}{\sqrt(2)} |0\rangle + \frac{1}{\sqrt(2)}|1\rangle$$ Im Falle eines 2-Qubit-Gatters würde eine unitäre $4\times 4$ Matrix herangezogen werden. Ein Beispiel ist das \textit{C-NOT} Gatter \[C = \begin{pmatrix}
		1 & 0 & 0 & 0\\
		0 & 1 & 0 & 0\\
		0 & 0 & 0 & 1\\
		0 & 0 & 1 & 0
	\end{pmatrix}\]
	
	\begin{lemma}
		Das innere Produkt hat folgende Eigenschaften:
		\begin{enumerate}
			\item $\langle \phi | \phi \rangle \geq 0$
			\item $\langle \phi | (a|\phi_1 \rangle + b|\phi_2 \rangle) = a \langle \phi | \phi_1 \rangle + b \langle \phi | \phi_2 \rangle$
			\item $\langle \psi | \phi\rangle^* = \langle \phi | \psi \rangle$
		\end{enumerate}
		Für eine $m\times n$ Matrix $A$ ist weiter \[(|A\psi \rangle , |A\phi \rangle) = \langle AA^t \psi | \phi \rangle\]
	\end{lemma}
	\begin{definition}
		Wir definieren weiter eine Qubit-Norm $||\cdot||: \mathbb{C}^n \to \mathbb{C}$ durch \[|||\phi \rangle || = \sqrt{\langle \phi | \phi \rangle}\]
		Dabei heißt ein Vektor $\phi$ unitär, wenn $|||\phi \rangle|| = 1$.
	\end{definition}
	
	\begin{definition}
		Wir definieren zu den Vektoren $|0\rangle$ und $|1\rangle$ eine Dualbasis durch $$|\nearrow\rangle = \frac{1}{\sqrt{2}}\binom{1}{1}$$ und $$|\searrow\rangle = \frac{1}{\sqrt{2}}\binom{1}{-1}$$. Dies ist eine Orthonormalbasis.
	\end{definition}
	
	\begin{definition}(Tensorprodukt)
		Seien $x = \binom{x_1}{x_2}$ und $y = \binom{y_1}{y_2}$ zwei Vektoren. Das Tensorprodukt ist definiert als \[x \otimes y = \begin{pmatrix}
			x_1y_1\\
			x_1y_2\\
			x_2y_1\\
			x_2y_2
		\end{pmatrix}\]
		Das ist leicht verallgemeinerbar für höher dimensionale Vektoren. Außerdem kann das Tensorprodukt auf Matrizen \[A = \begin{pmatrix}
			a_{1,1} & \dots & a_{1,n}\\
			\vdots & & \vdots\\
			a_{m,1} & \dots & a_{m,n}
		\end{pmatrix}\] und eine beliebig dimensionale Matrix $B$ angewandt werden durch \[A \otimes B = \begin{pmatrix}
			a_{1,1}B & \dots & a_{1,n}B\\
			\vdots & & \vdots\\
			a_{m,1}B & \dots & a_{m,n}B
		\end{pmatrix}\]
	\end{definition}
	Wenn mehrere Qubits $|\phi\rangle = \binom{\alpha}{\beta}$ und $|\psi\rangle =  \binom{\gamma}{\delta}$ vorliegen, dann schreiben wir \[|\phi\rangle |\psi\rangle = |\phi \psi \rangle = |\phi\rangle \otimes |\psi\rangle \in \mathbb{C}^4\]
	Wird $|\phi^n\rangle$ geschrieben, so ist damit das $n$-fache Tensorprodukt von $|\phi\rangle$ gemeint. 
	
	\begin{lemma}
		Das Tensorprodukt hat folgende Eigenschaften:
		\begin{enumerate}
			\item $|v\rangle \otimes |w\rangle + |v\rangle \otimes |u\rangle = |v\rangle (|w\rangle + |u\rangle)$
			\item $a(|v\rangle \otimes |w\rangle = a|v\rangle \otimes |w\rangle) = |v\rangle \otimes a|w\rangle$
			\item $(|u\rangle \otimes |v\rangle , |w\rangle \otimes |x\rangle) = (|u\rangle\otimes|w\rangle , |v\rangle\otimes|x\rangle)$
		\end{enumerate}
	\end{lemma}
	
	\subsection{Quantenschaltkreise}
	Diese unterscheiden sich von klassischen Schaltkreisen insofern, dass Operationen reversibel sind. In klassischen Schaltkreisen ist das nicht der Fall, da zum Beispiel bei einer $\land$ Verknüpfung mit Ergebnis 0 nicht auf die Eingabewerte rückgeschlossen werden kann. Quantenschaltkreise können verwendet werden um sowohl klassische als auch probabilistische Schaltkreise zu modellieren.
	\begin{theorem} [no cloning satz]
		Es gibt keine unitäre Transformation $U$, das ein Qubit $|\phi\rangle$ kopiert.
	\end{theorem}
	\begin{proof}
		Falls so ein $U$ existiert, dann gilt $\forall |\phi\rangle$ und $\forall |\psi\rangle$ immer $U|\phi 0 \rangle = |\phi\phi\rangle$ und $U|0\psi\rangle = |\psi\psi\rangle$. Dann gilt \[\langle\phi|\psi\rangle\langle\phi|\psi\rangle = \langle\phi\psi|\phi\phi\rangle = (U|\phi0\rangle, U|\psi0\rangle) = (U^tU|\phi0\rangle, |\psi0\rangle) = \langle\phi0|\psi0\rangle = \langle\phi|\psi\rangle\langle0|0\rangle\] Da 0 die Norm 1 hat folgt $\langle\phi|\psi\rangle = \langle\phi|\psi\rangle^2$ was nur für die Werte 0 und 1 der Fall ist.
	\end{proof}
	\subsection{Simulation klassischer Schaltkreise}
	Wir definieren das Fredkin Gatter $f(a,b,0) = (a,b,0)$ und $f(a,b,1) = (b,a,1)$ für $a,b \in \{0,1\}$. Dafür dient die folgende $8\times8$ Matrix: \[F = \begin{pmatrix}
		I_3 & 0 & 0\\
		0 & J_3 & 0\\
		0 & 0 & I_2 
	\end{pmatrix}\] wo $J_3$ die um 90° rotierte $3\times3$ Einheitsmatrix ist. Mit diesem können klassische Boole'sche Funktionen simuliert werden. Mit der obigen Matrix gilt $f(0,b,c) = (c\land b, \overline{c}\land b, c)$ und ist somit eine UND-Funktion. Der erste Output ist der für die Operation relevante Teil, die anderen beiden werden für die Umkehrung gebraucht. Ein ODER-Gatter kann mit $f(1,b,c) = (b\land\overline{c}, b\land c, c)$ simuliert werden. Zum Schluss ist eine Negation durch $f(0,1,c) = (c,\overline{c},c)$ darstellbar. Da diese drei Funktionen eine vollständige Basis sind, kann somit jeder klassische Schaltkreis durch Verkettung von Fredkin Gattern simuliert werden. Für einen klassischen Schaltkreis $c$ gibt es einen Quantenschaltkreis der Größe $p(\left|c\right|)$, der $c$ berechnet. 
	\subsection{Simulation probabilistischer Schaltkreise}
	Ein probabilistischer Schaltkreis ist ein klassische Schaltkreis, der als Eingabe mit gewisser Wahrscheinlichkeit eine Konstante bekommt und der das Ergebnis mit einer genügend großen Wahrscheinlichkeit berechnet.\\
	Die Eingabe ist dabei gegeben als Input $x$ und einer Menge $z$ an Zufallsbits. Die Aufgabe des Schaltkreises könnte es sein, mit Wahrscheinlichkeit $p>\frac{3}{4}$ zu berechnen, ob $x$ eine Primzahl ist.\\
	Der Input einer Zufallsvariablen kann durch Transformation mittels eines Hadamard Gatters und anschließender Messung des Qubits simuliert werden.
	\subsection{Die Komplexitätsklasse BQP}
	Im klassischen Sinne ist ein Problem $L$ einer Sprache $\Sigma^*$ in der Klasse P, wenn es einen polynomiellen Algorithmus gibt, der $L$ entscheidet.
	\begin{definition}[BPP - bounded error probabilistic polynomial time]
		Sei $L\subseteq \Sigma^*$. Dann gilt $L\in$BPP genau dann, wenn es eine probabilistische Turing Maschine mit Zufallsbits und ein Polynom $p$ gibt, sodass $\forall x \in \Sigma^*$
		\begin{itemize}
			\item $\forall x$ gilt $x \in L$ impliziert $p[c_n(x) = 1] \geq \frac{3}{4}$
			\item $\forall x$ gilt $x \notin $ ipliziert $p[c_n(x) = 0] \geq \frac{3}{4}$
			\item $c_n$ hat höchstes $c(n)$ Gatter
		\end{itemize}
	\end{definition}
	\begin{definition}[BQP - bounded error quantum polynomial time]
		Sei $L\subseteq \Sigma^*$. Dann gilt $L\in$BQP genau dann, wenn es eine Familie von Quantenschaltkreisen $\{c_1,...\}$ und ein Polynom $p$ gibt, sodass $\forall x \in \Sigma^*$ \begin{itemize}
			\item $\forall x$ gilt $x \in L$ impliziert $p[c_n(x) = 1] \geq \frac{3}{4}$
			\item $\forall x$ gilt $x \notin $ impliziert $p[c_n(x) = 0] \geq \frac{3}{4}$
			\item $c_n$ hat höchstes $c(n)$ Gatter
		\end{itemize}
	\end{definition} 
	\begin{remark}
		Es gilt BQP$\subset$BPP.
	\end{remark}
	\begin{definition}
		Sei $S$ eine Menge an Transformationen. $S$ ist eine universelle Menge für alle $U$ unitär, wenn $U$ mit Gattern aus $S$ approximiert werden kann. D.h. \[\forall \epsilon > 0 \; \exists G_1,G_2,...G_k \in S \text{ s.d. } ||U-G_1G_2...G_k|| < \epsilon\]
		Ein Beispiel für $S$ ist CNOT mit allen 1-Qubit Gattern. Diese ist aber unendlich groß. $S = \{\text{CNOT, H, } \frac{\pi}{8} = \begin{pmatrix}
			1&0\\0&e^{i\frac{pi}{4}}
		\end{pmatrix}\}$ ist ein endliches Beispiel.
	\end{definition}
	\begin{definition}[PP]
		$L \in PP$ gilt genau dann, wenn es eine polynomiell beschränkte nicht-deterministische Turin Maschine $M$ gibt sodass, \begin{itemize}
			\item $x \in L \Rightarrow$ die Anzahl der akzeptierenden Pfade in $M(x)$ ist größer als die Anzahl der verwerfenden Pfade in $M(x)$
			\item $x \notin L \Rightarrow$ die Anzahl der akzeptierenden Pfade in $M(x)$ ist höchstens die Anzahl der verwerfenden Pfade in $M(x)$
		\end{itemize}
		Das ist äquivalent zu $L \in PP \Leftrightarrow \exists f \in \#P, g \in FP$ sodass $\forall x \in L \Leftrightarrow f(x) \geq g(x)$.
	\end{definition}
	Wir wollen nun umgekehrt zeigen, dass jeder Quantenschaltkreis durch klassische Schaltkreise simuliert werden kann. Dafür betrachten wir $U = \{H, R, CNOT, Toffoli\}$, eine universelle Menge von Quantengatter. Mit Hilfe dieser Gatter ist es möglich, zu beweisen, dass $BQP \subseteq PP$.
	\section{Erste Quantenalgorithmen}
	Im Folgenden ist eine Relation für die $n$-te Hadamard Matrix $H_n$ wichtig. Man nummeriere die Zeilen dieser Matrix mit binär Zahlen von 0000... bis 111... als $x$ und die Spalten auf die selbe Weise als $y$. Es gilt dann $(H_n)_{x,y} = \frac{1}{\sqrt{2^n}}(-1)^{x\cdot y}$. Dabei wird $x\cdot y$ definiert als \[x\cdot y = \bigoplus_{i=1}^n x_i \land y_i\] 
	Wenn angenommen wird, dass für eine zu berechnende Funktion $f$ eine black box mit einem Quantenschaltkreis $U_f$ existiert, so soll die Anzahl der benötigten Anfragen an den Schaltkreis $U_f$ bestimmt werden.
	\subsection{Algorithmus von Deutsch}
	Sei $f:\{0,1\} \to \{0,1\}$. Wir wollen $f(0)\oplus f(1)$ berechnen. Im klassischen Fall müssen zwei Anfragen an $f$ gestellt werden, um $f(0)$ und $f(1)$ zu bestimmen. Der Deutsch Algorithmus löst das mit einer Abfrage wie folgt:\\
	Die Eingaben $|0\rangle$ und $|1\rangle$ werden Hadamar-transformiert, d.h. \[|01\rangle \overset{H}{\to} \frac{1}{2}(|0\rangle+|1\rangle)(|0\rangle - |1\rangle) = \frac{1}{2}(|00\rangle + |10\rangle - |01\rangle - |11\rangle)\] Nun gibt es vier verschiedene Fälle für $f$ wie in der obigen Tabelle. \begin{table}
		\centering
		\begin{tabular}{c|c}
			f(0) & f(1) \\
			\hline
			0 & 0\\
			0 & 1\\
			1 & 0\\
			1 & 1
		\end{tabular}
	\end{table}
	Allgemein folgt aber $\overset{U_f}{\to} \frac{1}{2}(|0(0\oplus f(0))\rangle + |1(0\oplus f(1))\rangle - |0(1\oplus f(0))\rangle - |1(1\oplus f(1))\rangle)$
	\subsection{Deutsch-Josza-Problem}
	Sei $f:\{0,1\}^n \to \{0,1\}$. $f$ ist von Typ 1, wenn $f(x) = 1 \lor f(x) = 0 \; \forall x$. $f$ ist von Typ 2, wenn $\left|\{x: \; f(x) = 0\}\right| = \left|\{x: f(x) = 1\}\right| = 2^{n-1}$, sich die Funktion also im Gleichgewicht befindet. Im klassischen Fall sind bis zu $2^{n-1}+1$ Abfragen nötig, um den Typen on $f$ zu bestimmen.\\
	In einem probabilistischen Schaltkreis werden zufällig $x \in \{0,1\}^n$ gewählt und berechne $f(x)$. Falls alle $f(x)$ gleich sind, ist mit hoher Wahrscheinlichkeit eine Funktion von Typ 1 vorliegend. Werden nun $k$ Eingaben zufällig und ``ohne Zurücklegen'' gezogen, dann ist die Fehlerwahrscheinlichkeit, wenn $k$ mal der selbe Funktionswert zurückgegeben wird, gegeben durch \[\prod_{i=1}^{k} \frac{2^{n-1}-i}{2^n-i} < \frac{1}{2^k}\] Mit dieser Ungleichung ist es leicht, ein $k$ zu finden, wodurch die Fehlerwahrscheinlichkeit kleiner als ein gegebenes $\varepsilon$ ist.\\
	Der Quantenschaltkreis nimmt als Input $|0^n\rangle$ und $|1\rangle$. Beide werden Hadamard-transformiert, wobei $H|0^n\rangle$ bereits in einer früheren Vorlesung berechnet wurde. Es ergibt sich \[|0^n\rangle|1\rangle \overset{H}{\to} \frac{1}{\sqrt(2^n)} \sum_{x \in \{0,1\}^n} |x\rangle\left(\frac{|0\rangle-|1\rangle}{\sqrt{2}}\right)\]
	Mit der Anwendung des Schaltkreises geht dies weiter zu \[\overset{U_f}{\to} \frac{1}{\sqrt(2^n)} \sum_{x \in \{0,1\}^n} |x\rangle\left(\frac{|f(x)\rangle-\overline{|f(x)\rangle}}{\sqrt{2}}\right)\] Weitere Vereinfachungen liefern anschließend \[\frac{1}{2^n}\sum_{z \in \{0,1\}} \alpha_z |z\rangle\left(\frac{|0\rangle - |1\rangle}{\sqrt{2}}\right)\] wobei \[\alpha_z = \sum_{x \in \{0,1\}^n} (-1)^{xz\oplus f(x)}\] 
	Mit nur einer Abfrage kann der Typ bestimmt werden, wodurch die Funktion bereits eindeutig definiert ist. Mit diesem Quantenparallelismus ist also nur eine Messung nötig.
	\subsection{Simon's Algorithmus}
	Wir betrachten $f: \{0,1\}^n \to \{0,1\}^n$ und $a \in \{0,1\}^n$ und wir repräsentieren mit $\oplus$ das bitweise XOR. $f$ besitzt diese Eigenschaften:
	\begin{enumerate}
		\item $\forall x \in \{0,1\}^n$, $f(x) = f(x\oplus a)$
		\item $\forall x,y$ mit $y\neq x$ und $y\neq x\oplus a$ gilt $f(x)\neq f(y)$. D.h. es liegt eine 2-zu-1 Funktion vor
	\end{enumerate}
	Das Problem ist, $f$ zu finden.\\
	\begin{remark}[Klassischer Ansatz]
		Für jedes $x$ lässt sich $f(x)$ berechnen. D.h. finden wir $x_1$ und $x_2$ mit $f(x_1) 0 f(x_2)$, so erhalten wird $x_1 = x_2 \oplus a$ und damit $a = x_1\oplus x_2$.\\
		Generell gilt, werden $k$ verschiedene Inputs probiert und ist $f(x_i) \neq f(x_j)$ für alle $i,j \leq k$, so können $\binom{k}{2}$ Werte ausgeschlossen werden. Damit nur ein $a$ übrig bleibt, müssen also so viele $k$ probiert werden, damit \[2^n-1-\binom{k}{2} = 1\] gilt. D.h. $k = \Omega(\sqrt{2^n})$.
	\end{remark}
	\begin{remark}[Probabilistischer Ansatz]
		Sei $a'$ zufällig in $\{0,1\}^n \setminus 0^n$. Es gilt $\mathbb{P}[a' = a] = \frac{1}{2^n-1}$ ist unabhängig von $a'$. Wir nehmen wieder $k$ Stichproben mit paarweise verschiedenen Funktionswerten $x_1,...,x_k$, sodass gilt $x_i \neq x_j$ für alle $i,j\leq k$ an. Nun gilt $\mathbb{P}[\underbrace{a = a'}_{=A}| \underbrace{f(x_i) \neq f(x_j), \; x_i \neq x_j}_{=B}]$. Nun ist bekannt, dass $P[B|A] = 1$. $\mathbb{P}[B]$ ist unabhängig von $a'$. Es folgt daher, dass $P[A|B]$ komplett unabhängig von der Wahl von $a'$ ist. Eben da diese Wahrscheinlichkeit für alle noch nicht getesteten $a'$ gleich ist, müssen weiterhin $\sqrt{2^n}$ Stichproben gemacht werden.
	\end{remark}
	\begin{remark}[Quanten Ansatz]
		Der Schaltkreis besteht aus zwei mal der Eingabe $|0^n\rangle$, wobei der Ablauf so aussieht \[|0^n\rangle |0^n\rangle \overset{H_n}{\to} \frac{1}{\sqrt{2^n}} \sum_{x \in \{0,1\}^n} |x\rangle |0^n\rangle \overset{U_f}{\to} \frac{1}{\sqrt{2^n}} \sum_{x \in \{0,1\}^n} |x\rangle |f(x)\rangle \overset{M_n}{\to} \frac{|x\rangle |f(x)\rangle + |x\oplus a\rangle|f(x)\rangle}{\sqrt{2}}\] Durch eine weitere Hadamard Transformation auf dem ersten $n$-Qubits erhält man daraus \[\frac{1}{\sqrt{2^n}} \left( \sum_{z \in \{0,1\}^n} (-1)^{zx}(1+(-1)^{za})|z\rangle\right) |f(x)\rangle = \sum_{z \in \{0,1\}^n} \alpha_z|z\rangle|f(x)\rangle\] mit \[\alpha_z = \frac{(-1)^{zx}(1+(-1)^{za})}{\sqrt{2^{n+1}}}\]
		Nun gilt, falls $za = 1$, so gilt $\alpha_z= 0$. Darum messen wir nur $z$ mit $za = 0$, gilt $\alpha_z = \frac{(-1)^{zx}}{\sqrt{2^{n-1}}}$. D.h. $\left|\alpha_z\right|^2$ ist gleich für alle $z$ mit $za = 0$.\\
		Bemerke nun, dass $za = 0 \Rightarrow \bigoplus_{i=1}^n z_i\land a_i = 0$. Das heißt, $z$ ist orthogonal zu $a$. Um genau zu sein, erhält man diese Relation für alle $n-1$ Vektoren $z^k$, die orthogonal zu $a$ sind. Formaler ist $\{z \in \{0,1\}^n: \; za = 0\}$ ist ein Untervektorraum mit Dimension $n-1$. Wir brauchen also $n-1$ l.u. $z$ mit $za = 0$, um das System lösen zu können und $a$ zu berechnen. Dafür sind die folgenden Schritte da.\\
		\underline{Schritt 1} Generiere $z_1\neq 0^n$ mit $z_1a = 0$. Das hat Wahrscheinlichkeit $1-\frac{1}{2^{n-1}}$.\\
		\underline{Schritt 2} Generiere $z_2$ mit $z_2a = 0$ das linear unabhängig zu $z_1$ und $0^n$ ist. Das hat Wahrscheinlichkeit $1-\frac{2}{2^{n-1}}$\\
		\underline{Schritt $k$} Generiere $z_k$ mit $z_ka = 0$ das linear unabhängig zu dem Raum erzeugt von den vorherigen $k-1$ Vektoren und $0^n$ ist. Das hat Wahrscheinlichkeit $1-\frac{2^{k-1}}{2^{n-1}}$.\\
		Wir sehen, dass die Wahrscheinlichkeit $n-1$ solche Vektoren zu generieren \[\prod_{j=1}^{n-1} (1-\frac{2^{j-1}}{2^{n-1}}) \leq \frac{1}{4}\] ist. Wird dieses Experiment $k$ mal wiederholt, so ist die Wahrscheinlichkeit, dass alle Experimente Vektoren produzieren, die linear abhängig sind, $\frac{3}{4}^k \leq \frac{1}{2^{k-2}}$. Bei $k(n-1)$ Stichproben, findet man $a$ mit Wahrscheinlichkeit $\geq 1-\frac{1}{2^{k-2}}^k$. 
	\end{remark}
	\section{Suchalgorithmus von Grover}
	Sei $f:\{0,1\}^n \to \{0,1\}$ und $U_f$ ein Schaltkreis, der $f$ berechnet. Gesucht ist ein $a \in \{0,1\}^n$ mit $f(a) = 1$. Es kann angenommen werden, dass es nur genau ein $a$ mit $f(a) = 1$ gibt. Wir definieren für leichtere Schreibweise $2^n = N$. Wir interessieren uns für die Anzahl an Anfragen an $f$. Im klassischen Fall müssen damit bis zu $N-1$ Anfragen gestellt werden. Im probabilistischen Fall ist der Erwartungswert $\frac{2N-1}{2}$. Im Quantenfall genügen hingegen $\mathcal{O}(\sqrt{N})$ Anfragen. Im Folgenden wird das bewiesen.\\
	\begin{definition}[$D$ Transformation]
		\[D = \begin{pmatrix}
			\frac{2}{N} - 1 & \frac{2}{N} & \dots & \dots & \frac{2}{N}\\
			\frac{2}{N} & \frac{2}{N} - 1 & \frac{2}{N} & \dots & \frac{2}{N}\\
			\vdots & & \ddots & & \vdots\\
			\frac{2}{N} & \dots & \dots & \dots & \frac{2}{N} -1
		\end{pmatrix}\]
		Diese Matrix wird Diffusions-Matrix genannt. Man sieht, dass für \[D \begin{pmatrix}
			\alpha_1\\
			\vdots\\
			\alpha_N
		\end{pmatrix} = \begin{pmatrix}
			\beta_1\\
			\vdots\\
			\beta_N
		\end{pmatrix}\]
		Wobei $\beta_i = \frac{2}{N}\sum_{j=1}^N \alpha_k - \alpha_i$. Das heißt für den Durchschnitt der Amplituden $\mu = \sum_{j=1}^N \frac{\alpha_j}{N}$ ist $\beta_i = 2\mu - \alpha_i$.
	\end{definition}
	Als Eingabe Qubits dienen wieder $|0^n\rangle$ und $|0\rangle$. Diese werden Hadamard transformiert und das Resultat in $U_f$ eingegeben. Der obere Output von $U_f$ wird $D$ transformiert. $U_f$ mit anschließender $D$ Transformation wird $G$ genannt. Der Grover Algorithmus funktioniert durch $m$-males Anwenden von $G$. Zusammengefasst:
	\begin{eqnarray*}
		|0^n\rangle |0\rangle \overset{H}{\to} \frac{1}{\sqrt{N}} \sum_{z \in \{0,1\}^n} |z\rangle \left(\frac{|0\rangle +|1\rangle}{\sqrt{2}}\right) \overset{U_f}{\to} \frac{1}{\sqrt{N}} \sum_{z \in \{0,1\}^n} (-1)^{f(z)}|z\rangle \left(\frac{|0\rangle +|1\rangle}{\sqrt{2}}\right)
	\end{eqnarray*}
	Durch $t$-maliges Anwenden von $G$ sind die Werte $\alpha_x^t$ gegeben. Insbesondere ist $\alpha_a^1 = \frac{3}{\sqrt{N}} -\frac{4}{N\sqrt{N}}$ und $\alpha_x^1 = \frac{1}{\sqrt{N}} -\frac{4}{N\sqrt{N}}$ für $x\neq a$. Generell ist \[\alpha_a^t = 2\mu_{t-1} + \alpha_a^{(t+1)} = -\frac{2}{N} \alpha_a^{(t-1)} + \left(1-\frac{2}{N}\right)\alpha_x^{(t-1)}\] wobei $\mu_t$ der Durchschnitt der Amplituden nach $t$ maliger Anwendung von $G$ sei. Lösen liefert $\alpha_a^t = \sin((2t+1)\Theta)$ und $\alpha_x^t = \frac{1}{\sqrt{N-1}}\cos((2t+1)\Theta)$ wobei $sin^2(\Theta) = \frac{1}{N}$. Nun soll die Wahrscheinlichkeit für $\alpha_x^t$ minimiert werden, d.h. gesucht ist ein $\Theta$, sodass $\cos((2t+1)\Theta) = 0$. Für $t = \frac{\pi}{4\Theta} - \frac{1}{2} + m\frac{\pi}{\Theta}$ ist der Cosinus gleich 0. Das heißt für großes $N$ genügt $t = \lfloor \frac{\pi}{4\Theta}\rfloor$ damit der Cosinus ungefähr 0 ist. $t$ ist damit in $\mathcal{O}(\sqrt{N})$.\\
	Im allgemeinen Fall, wenn $\left|\{x | f(x) = 1\}\right| = M$, dann findet man mit großer Wahrscheinlichkeit ein $x$ mit $f(x) = 1$ in $t = \sqrt{\frac{N}{M}}$ Iterationen. Geometrisch kann man sich den Algorithmus als eine Rotation der Qubits vorstellen.
	\subsection{Untere Schranke für den Grover-Suchalgorithmus}
	Für die untere Schranke wird ein Algorithmus $A$ betrachtet, der bildlich gesprochen Fragen an $U_f$ stellen kann. Dafür steht im Folgenden $O$, also Orakel.\\
	Die Behauptung ist, dass $A$ $\Omega(\sqrt{N})$ Anfragen an $U_f$ stellen muss, um $a$ zu bestimmen. $A$ kann wie folgt geschrieben werden: \[\underbrace{U_TOU_{T-1}...U_1OU_1O}_A|0^n\rangle\] Die Anzahl an Fragen ist daher $T$. Für den Beweis wird das folgende Lemma benötigt:
	\begin{lemma}
		Seien $|\phi\rangle = \sum_{i=1}^n \alpha_i |i\rangle$ und $|\psi\rangle = \sum_{i=1}^n \beta_i |i\rangle$ zwei Quantenzustände, sodass \[\sum_{i=1}^n \left|\left|a_i\right|^2 - \left|\beta_i\right|^2\right| > \varepsilon\] dann ist \[\left|\left||\phi\rangle - |\psi \rangle\right|\right| > \frac{\varepsilon}{2}\]
	\end{lemma}
	Wir definieren die Funktion $f(z) = 0 \; \forall z$ und das dazugehörige Orakel $O_f$. Wir definieren $|\psi_t\rangle =  U_tOU_{t-1}...U_1OU_1O_A|0^n\rangle = \sum_{i=1}^n \alpha_i^t |i\rangle$. Außerdem definieren wir $q_x(\psi_t) = \left|\alpha_x^t\right|^2$. Man kann sehen, dass \[\sum_{t=1}^{T} \sum_{x \in \{0,1\}^n} q_x(\psi_t) = T = \sum_{x \in \{0,1\}^n} \sum_{t=1}^T q_x(\psi_t) \Rightarrow \; \exists x_0: \; \sum_{x \in \{0,1\}^n} \sum_{t=1}^T q_{x_0}(\psi_t) \leq \frac{T}{N}\]
	Damit wird eine neue Funktion definiert \[g(x) = \begin{cases}
		1, \; x = x_0\\
		0, \; x \neq x_0
	\end{cases}\]
	Dann sei $|\psi'_T\rangle = U_TO_gU_{t-1}O_g...U_1O_gU_0|0^n \rangle$. Nach einer Messung erkennt man bereits einen Unterschied in den beiden Schaltkreisen, woraus folgt, dass \[\sum_{i=1}^n \left|\left|\alpha_i\right|^2 - \left|\alpha_i'\right|^2\right| > \varepsilon > 0\] Wir schließen mit obigem Lemma \[|||\psi_T\rangle - |\psi_T'\rangle|| > \frac{\varepsilon}{2}\]
	Wir definieren aus diesen beiden Zuständen einen neuen Zustand \[|\psi_T\rangle_i = U_TO_gU_{T-1}O_g ... O_gU_iO_fU_{i-1}O_f ... O_fU_1O_fU_0|0^n\rangle\]
	Wir finden \begin{eqnarray*}
		\varepsilon < |||\psi_T\rangle - |\psi_T'\rangle|| < |||\psi_T\rangle_T - |\psi_T\rangle_0|| = |||\psi_T\rangle_T - |\psi_T\rangle_i + |\psi_T\rangle_i - |\psi_T\rangle_0|| = ||\sum_{t=1}^T |\psi_T\rangle_t - |\psi_T\rangle_{t-1}||\\
		\overset{\Delta}{\leq} \sum_{t=1}^T ||\underbrace{|\psi_T\rangle_t - |\psi_T\rangle_{t-1}}_{=E_i}|| = \sum_{t=1}^T ||E_i||
	\end{eqnarray*}
	Zur Vereinfachung schreiben wir nun:\\
	$|\psi_T\rangle_i = \underbrace{U_TO_g ... O_gU_i}_{= U} O_f\underbrace{U_{i-1} ... O_fU_0}_{=|\psi_i\rangle}|0^n\rangle$ und \\
	$|\psi_T\rangle_{i-1} = \underbrace{U_TO_g ... O_gU_i}_{= U} O_gU_{i-1} ... O_fU_0|0^n\rangle$. Es gilt dann $|\psi_T\rangle_{i-1} = UO_g|\psi_i\rangle = U(|\psi_i\rangle - 2\alpha_{x_0}^i |x_0\rangle)$, also \[\sum_{t=1}^T ||E_i|| \leq \sqrt{\sum_{t=1}^T ||E_i||^2 T} = \sqrt{\sum_{t=1}^T 4|\alpha_{x_0}^i|^2 T} = 2\sqrt{\sum_{i=1}^n q_{x_0}(\psi_i) T} \leq 2\frac{T}{\sqrt{N}}\]
	Geht man zurück zu oberer Forderung mit $\varepsilon$, so findet man durch gegenüberstellen der beiden Ungleichungen $T = \frac{\varepsilon\sqrt{N}}{4} \in \Omega(\sqrt{N})$.
	\subsection{Anwendungen vom Grover-Algorithmus}
	\begin{definition}[QSEARCH]
		Sei $f:\{0,1\}^n \to \{0,1\}^n$ und sei $M = \left|\{x\in \{0,1\}^n| f(x) = 1\}\right|$. Wenn $M\neq 0$, dann nehmen wir an, dass QSEARCH ein $x$ mit $f(x) = 1$ in erwarteter Zeit $\mathcal{O}(\sqrt{\frac{N}{M}})$ findet. Alle solche $x$ sind gleich wahrscheinlich. Wenn $M = 0$, dann hält QSEARCH nicht.
	\end{definition}
	\subsubsection{Minimumsproblem}
	Sei $f:\{0,...,N-1\} \to \{0,...,M\}$ injektiv. Finde $x$, sodass $\forall y \neq x$ gilt $f(x) < f(y)$. Als Komplexitätsmaß wird die Anzahl der Vergleiche herangezogen. Wir werden sehen, dass der Quanten-Ansatz $\Theta(\sqrt{N})$ Vergleiche benötigt.\\
	Definiere für ein festes $y$ die Funktion \[g_y(x) = \begin{cases}
		1, f(x)<f(y)
		0, \text{ sonst}
	\end{cases}\]
	Wir definieren den Schaltkreis $U_g$ für $g$ mit den Inputs $x,y$ und einem zusätzlichen Qubit $b$ und den Ausgängen $x,y$ und $b\oplus g_y(x)$. Der Algorithmus funktioniert schließlich wie folgt: 
	\begin{enumerate}
		\item Wähle $y\in_R \{0,..,N-1\}$
		\item REPEAT
		\item $|\Phi\rangle := (H_n|0^n\rangle) |y\rangle|1\rangle$
		\item $QSEARCH(g_y(x))$
		\item $y'$ = Messung der ersten $n$ Register
		\item IF $f(y') < f(y)$ THEN $y=y'$
		\item t=t+1
		\item UNTIL $t>l$
		\item AUSGABE $(y,f(y))$
	\end{enumerate}
	Dabei ist $l$ ein Parameter, der später fixiert wird.
	\begin{lemma}
		Sei $p(q,r)$ die Wahrscheinlichkeit, dass der Algorithmus das $r$-kleinste Element bei $q$ Elementen wählt. Dann ist $p(q,r) = \frac{1}{r}$, wenn $r\leq q$ und $0$ sonst.
	\end{lemma}
	\begin{lemma}
		Die erwartete Anzahl an Fragen an $U_g$ bis das Argminimum $y$ gefunden wird, ist $\mathcal{O}(\sqrt{N})$. 
	\end{lemma}
	\subsubsection{Untere Schranke}
	Sei $g:\{0,...,N-1\} \to \{0,...,2N-1\}$ und $g(i) = i+N(1-f(i))$ wobei $f: \{0,...,N-1\} \to \{0,1\}$. Falls $\forall x$, $f(x) = 0 \Leftrightarrow g(i) = i+N$. Falls $\exists x$, $f(x) = 1$, dann $g(x) = x$. Es gilt \[\min g(x) \geq N \Leftrightarrow \; \forall x\; f(x) = 0\] und \[\min g(x) < N \Leftrightarrow \exists x:\; f(x) = 1\] Würde nun ein Algorithmus existieren, der weniger als $\Omega(\sqrt{N})$ Laufzeit benötigt, dann könnte Grover's Algorithmus genauso verbessert werden, was nicht möglich ist.
	\subsubsection{Element Distinctness}
	Sei $f: \{0,...,N-1\} \to \{0,...,M-1\}$ mit $M>N$. Das Problem ist, zu bestimmen, ob $f$ injektiv ist.
	\section{Shor Algorithmus}
	\subsection{Diskrete Fourier Transformation}
	Ein Vektor $(x_0,...,x_{N-1})$ wird durch DFT transformiert auf $(y_0,...,y_{n-1})$ wobei \[y_j = \sum_{k=0}^{N-1} \exp\left(\frac{2\pi ijk}{N}\right)x_k = \sum_{k=0}^{N-1} x_k(w_{k,N})^j\] wobei definiert wird \[\exp\left(\frac{2\pi ik}{N}\right):= w_{k,N}\]
	Mit $\exp\left(\theta i\right) = \cos(\theta) + i \sin(\theta)$ kann die Darstellung weiter vereinfacht werden. Die Transformation kann auf eine Matrixmultiplikation zurückgeführt werden. Mit der Fast Fourier Transformation (FFT) kann diese in $\mathcal{O}(N\log N)$ Zeit ausgeführt werden.
	\subsection{Quantum Fourier Transformation}
	Diese ist definiert durch \[|j\rangle \overset{QFT}{\to} \frac{1}{\sqrt{N}}\sum_{k=0}^{N-1}(w_{k,N})^j|k\rangle\] Insbesondere \[\sum_{j=0}^{N-1} x_j|j\rangle \overset{QFT}{\to} \frac{1}{\sqrt{N}} \sum_{j=0}^{N-1}x_j\sum_{k=0}^{N-1} (w_{k,N})^j|j\rangle = \frac{1}{\sqrt{N}}\sum_{k=0}^{N-1}\sum_{j=0}^{N-1}x_j(w_{k,N})^j|x\rangle = \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} y_k |k\rangle\]
	Diese kann man wieder als Matrix $F_{N\times N}$ schreiben, wobei \[(F_{N\times N})_{a,b} = \frac{1}{\sqrt{N}}(w_{1,N})^{ab}\]
	Diese kann in kleinere Matrizen zerlegt werden. Dafür schreiben wir \[|j\rangle = |j_1,...,j_N\rangle \; j_i \in \{0,1\}\]
	Die Darstellung als Quantenschaltkreis ist kompliziert. Wir schreiben \[b(0.j_l...,j_N) = \sum_k=l^{N}j_k\frac{1}{2^{k-l+1}}\] und bemerken $b(0.j_1...j_N) = j$. Die QFT kann nun geschrieben werden als \[QFT(|j\rangle) = \frac{1}{\sqrt{N}}(|0\rangle + e^{2\pi i b(0.j_N)}|1\rangle)(|0\rangle + e^{2\pi i b(0.j_{N-1}j_N)}|1\rangle) ... (|0\rangle + e^{2\pi i b(0.j_1...j_N)}|1\rangle)\]
	\subsection{Algorithmus für die Faktorisierung}
	Sei $N \in \mathbb{N}$ teilbar. Gesucht sind $x \in \mathbb{N}\setminus\{1,N\}$ sodass $x|N$. Die besten klassischen Algorithmen brauchen $\mathcal{O}(2^{\left|N\right|})$, wobei $\left|N\right|$ die Anzahl der Bits von $N$ ist, d.h. $\left|N\right| \approx \log N$. Dieses Problem ist Grundlage für viele andere Probleme, so zu, Beispiel das Ordnungsproblem: \begin{definition}[Ordnungsproblem]
		Gegeben $Y, N \in \mathbb{N}$, $Y<N$ und $ggT(Y,N) = 1$. Finde \[\arg\min_r \{Y^r \equiv 1 \mod N\}\] So ein $r$ muss existiert immer, denn $Y$ und $N$ sind teilerfremd.
	\end{definition}
	\begin{lemma}
		Sei $N\in \mathbb{N}$ teilbar. Falls $\exists x$ sodass $x^2 \equiv 1 \mod N$ und $x \not\equiv 1 \mod N$ und $x \not \equiv -1 \mod N$, dann $ggT(x,N) \neq 1$ und $ggT(x,N) \neq N$.
	\end{lemma}
	\begin{lemma}
		Sei $N = p_1^{e^1}p_2^{e_2}...p_m^{e_m}$ die Primfaktorzerlegung von $N$. Im Allgemeinen können wir annehmen $N\neq 2$. Definiere $r_Y$ als die Ordnung $ord(Y,N)$ eines Elementes $Y$. Unter Gleichverteilung wähle der Elemente $Y$ mit $ggT(Y,N) = 1$ gilt \[\mathbb{P}[r_Y \text{ gerade und } Y^{\frac{r_Y}{2}} \not \equiv \pm 1 \mod N] \geq 1-2^{-m} \geq \frac{1}{2}\]
	\end{lemma}
	Auf dieser Basis kann ein Algorithmus für die Faktorisierung gefunden werden:\\
	\begin{enumerate}
		\item Eingabe $N$
		\item Ausgabe Faktor von $N$ oder ? falls keiner existiert
		\item IF $N$ gerade Then Ausgabe 2
		\item ELSE WÄHLE $y \in _R [3,...,N-1]$
		\item IF $ggT(N,Y) > 1$ Then Ausgabe 
		\item ELSE $r_Y = ord(Y,N)$
		\item IF $r_Y$ gerade und $y^{\frac{r_Y}{2}} \not \equiv \pm 1 \mod N$ Then Ausgabe $ggT(N, y^\frac{r_Y}{2}+1)$
		\item ELSE Ausgabe ?
	\end{enumerate}
	Dieser Algorithmus findet einen Faktor mit Wahrscheinlichkeit $\geq \frac{1}{2}$, durch $k$-fache Wiederholung kann die Fehlerwahrscheinlichkeit klein gemacht werden.
	\subsection{Algorithmus für das Ordnungsproblem}
	Gegeben $Y,N$ mit $ggT(Y,N) = 1$. Es sei $Q>>N$ (z.B. $Q = N^2$), $n = \left|N\right|$ und $q = \left|Q\right|$ Als Eingabe fungieren zwei Register $|0^q\rangle$ und $|0^n\rangle$. Nun wird \begin{enumerate}
		\item Fourier Transformation auf das erste Register angewandt, dann erhält man \[\frac{1}{\sqrt{Q}}\sum_{k=0}^{Q-1}|k\rangle |0^n\rangle\] Das ist eigentlich eine Hadamard Transformation
		\item die modulare Potenzfunktion $f_{Y,N}(k) = Y^k \mod N$ auf Register 2 berechnet \[\frac{1}{\sqrt{Q}} \sum_{k=0}^{Q-1} |k\rangle |Y^k \mod N\rangle\]
		\item eine Messung auf dem zweiten Register durchgeführt. \[\frac{1}{\sqrt{A}}\sum_{j=0}^{A-1}|jr+k_0\rangle |Y^{k_0} \mod N\rangle \] für $A=\frac{Q}{r}$. Wenn $r$ die Ordnung ist, dann gibt es nämlich $r$ unterschiedliche Werte für $Y^k\mod N$.
		\item QFT auf dem ersten Register angewandt. \[\frac{1}{\sqrt{Q}}\sum_{l=0}^{Q-1} \left(\frac{1}{\sqrt{A}} \sum_{j=0}^{A-1} e^{\frac{2\pi i(jr+k_0)l}{Q}}|l\rangle |Y^k \mod N\rangle\right)\]
		\item eine Messung auf dem ersten Register ausgeführt. Dadurch erhält man ein $l$ mit Wahrscheinlichkeit \[\left|\frac{1}{\sqrt{QA}}\sum_{j=0}^{A-1} e^{\frac{2\pi i(jr+k_0)l}{Q}}\right|^2 = \frac{1}{QA}\left|e^{\frac{2\pi i k_0 l}{Q}} \sum_{j=0}^{A-1} e^\frac{2\pi i j r l}{Q}\right|^2 = \frac{1}{QA}\left|\sum_{j=0}^{A-1} e^\frac{2\pi i j r l}{Q}\right|^2\] weil $$\left|e^{\frac{2\pi i k_0 l}{Q}}\right|^2 = \left(\cos^2\theta + \sin^2 \theta\right)^2 = 1$$
	\end{enumerate}
	\begin{example}
		Es sei $N=15$ und $Y=7$. gesucht wird $Ord(Y,N) = \min_r \{Y^r \equiv 1 \mod N\}$. Es gilt \begin{itemize}
			\item $Y = 7$
			\item $Y^2 \equiv 4$
			\item $Y^3 \equiv 13$
			\item $Y^4 \equiv 1$, d.h. der Algorithmus müsste $r = 4$ finden
		\end{itemize}
		Wir wählen jetzt $Q>>N$, z.B. $Q = 2^8$ und da $N < 2^4$, also $n=4$ und $q=8$, beginnen wir mit der Eingabe \[|0^4\rangle|0^8\rangle \to \frac{1}{\sqrt{2^8}} \sum_{k=0}^{Q-1} |k\rangle|0^n\rangle\]
		Nun berechnen wird die modulare Potenzfunktion auf dem zweiten Qubit und erhalten \[\frac{1}{\sqrt{2^8}}\sum_{k=0}^{Q-1} |k\rangle |Y^k \mod N\rangle\] Wir wissen bereits, dass das zweite Qubit daher nur die Werte $7,4,13$ und $1$ annehmen kann. Insbesondere wissen wir $A =\frac{Q}{r} = 64$. Nun wird das zweite Qubit gemessen, erhält man z.B. als Wert $m=7$, so korrespondiert das zu dem Term \[\frac{1}{\sqrt{64}}\sum_{j=0}^{63} |jr+1\rangle |7\rangle\]
		Nun wird eine Quanten-Fourier-Transformation auf das erste Qubit angewandt und man erhält \[\frac{1}{2^8} \sum_{l=0}^{63}\left(\frac{1}{8}\sum_{j=0}^{63} e^{\frac{2\pi i (4j+1)l}{2^8}}|l\rangle |7\rangle\right)\]
		Nun wird auf dem ersten Qubit gemessen und wir erhalten den Wert $l$ mit Wahrscheinlichkeit \[\mathbb{P}(l) = \frac{1}{QA}\left|\sum_{j=0}^{A-1} \left(e^{\frac{2\pi i rl}{Q}}\right)^j\right|^2\]
		Das ist eine geometrische Summe, für die gilt \[\sum_{j=0}^{A-1} c^j = \frac{1-c^A}{1-c}\] für $\left|c\right|<1$, was in unserem Fall erfüllt ist. Nun gibt es zwei Fälle:\\
		\underline{Fall 1:} $r$ teilt $Q$, d.h. $A = \frac{Q}{r}$.\\
		Dann \[\sum_{j=0}^{A-1} \left(e^{\frac{2\pi i rl}{Q}}\right)^j = \sum_{j=0}^{A-1} \left(e^{\frac{2\pi i l}{A}}\right)^j = \begin{cases}
			A, \text{ falls } e^{\frac{2 \pi i l}{A}} = 1 \text{ und } \frac{l}{A} \in \mathbb{N}                     \\
			\frac{1-\left(e^{\frac{2 \pi i l}{A}}\right)^A}{1-\left(e^{\frac{2 \pi i l}{A}}\right)} = 0 \text{ sonst}
		\end{cases}\]
		Wir messen daher nur solche $l$ mit $\frac{lr}{Q} \in \mathbb{N}$ und alle sind gleich wahrscheinlich. Nun gilt also $l \in \{0,1,...,Q-1\}$, wobei $lr = Qm$ für ein $m \in \mathbb{Q}$. D.h. $lr \in \{0,Q,2Q,...,mQ,...,(r-1)Q\}$ induziert eine Gleichverteilung in $m$.\\
		Tatsächlich wissen wir, dass $r=4$, also ist die Situation folgende: $l = 2^6m$ und wegen $l \in \{0, 2^6, 2\cdot 2^6, 3\cdot 2^6\}$ gilt $m \in \{0,1,2,3\}$. Ist nun $ggT(m,r) = 1$, so ist $r$ der Nenner von $\frac{l}{Q}$. Nun ist die Frage, mit welcher Wahrscheinlichkeit $ggT(m,r) = 1$ für $m \in \{0,1,...,r-1\}$ gilt.\\
		$\rightarrow$ falls $m$ eine Primzahl ist, so gilt trivial $ggT(m,r) = 1$. Da die Anzahl der Primzahlen kleiner $n$ ungefähr durch $\frac{n}{\ln n}$ gegeben ist, gilt \[\mathbb{P}(ggT(m,r) = 1) \geq \mathbb{P}(m \text{ prim}) \geq \frac{\frac{r}{\ln r}}{r} = \frac{1}{\ln r} \geq \frac{1}{\ln N}\] Führen wir diesen Algorithmus zum Beispiel $200\cdot \ln N$ mal aus, so ist der Fehler $<2^{-100}$.\\
		\underline{Fall 2:} $r$ teilt nicht $Q$, d.h. $A = \lceil \frac{Q}{r}\rceil \neq \frac{Q}{r}$.\\
		Falls $lr \mod Q \approx 0$, oder konkreter, falls \[-\frac{r}{2} \leq lr \mod Q \leq \frac{r}{2}\]
		Genau $r$ Werte $l$ erfüllen $-\frac{r}{2} \leq l \mod Q \leq \frac{r}{2}$. Für solche Werte ist $$e^{\frac{2\pi i l r }{Q}} = e^{\frac{2\pi i(Q\cdot k + m)}{Q}} = e^{\frac{2\pi i m}{Q}}$$ für ein $m$ mit $-\frac{r}{2} \leq m \leq \frac{r}{2}$. Wir schließen, dass \[\mathbb{P}(\text{Messung = }l) = \frac{1}{QA}\left|\sum_{j=0}^{A-1}\left(e^{\frac{2\pi i m}{Q}}\right)^j\right|^2 \geq \frac{1}{QA} \left|\sum_{j=0}^{A-1}\left(e^{\frac{2\pi i \frac{r}{2}}{Q}}\right)^j\right|^2 = \frac{1}{QA}\left|\frac{1-e^{\frac{\pi i r A}{Q}}}{1-e^{\frac{\pi i r}{Q}}}\right|^2\]
		An dieser Stelle können die Exponentialdarstellungen in $\cos \theta + i \sin \theta$ umgeschrieben werden, wodurch man \[\frac{1}{QA}\left(\frac{1+\cos^2 \theta - 2\cos \theta + \sin^2 \theta}{1 + \cos^2 \gamma - 2\cos \gamma + \sin^2 \gamma}\right) = \frac{1}{QA} \frac{1-\cos\left(\frac{\pi r A}{Q}\right)}{1 - \cos \left(\frac{\pi r}{A}\right)} = \frac{1}{QA}\frac{\sin^2 \frac{\pi r A}{2Q}}{\sin^2 \frac{\pi r}{2 Q}} \approx \frac{4Q}{\pi^2Ar^2} \approx \frac{4}{\pi^2 r}\]
		Wir schließen, dass die Wahrscheinlichkeit der Messung eines $l$ mit $-\frac{r}{2} \leq l \mod Q \leq \frac{r}{2}$ mindestens $\frac{4}{\pi^2}$ ist.\\
		Da wir außerdem wissen, dass $\left|lr-mQ\right|\leq \frac{r}{2}$ erhalten wir $\left|\frac{l}{Q} - \frac{m}{r}\right| \leq \frac{1}{2Q}$. Darauf kann folgendes Lemma verwendet werden.
		\begin{lemma}
			Es gibt höchstens ein Paar $(a,b)$ mit \[\left|\frac{l}{Q} - \frac{a}{b}\right| \leq \frac{1}{2Q}\] mit $b<N$ und $Q\geq N^2$.
		\end{lemma}
		\begin{proof}
			Falls $(a,b)$, $(a',b')$ mit $\frac{a}{b} > \frac{a'}{b'}$ und $b,b' \leq N$, dann ist $\frac{a}{b} - \frac{a'}{b'} = \frac{ab'-a'b}{bb'}\leq \frac{1}{Q}$. Nun gilt $ab'-a'b > 0$ und $bb' < N^2 < Q$, wodurch der Widerspruch gezeigt ist.
		\end{proof}
		Für die Darstellung wird die Methode der Continued fractions eingeführt. Für $\alpha \in \mathbb{R}$ ist $$\alpha = \alpha_0 + \frac{1}{\alpha_1 + \frac{1}{\alpha_2 + \frac{1}{\alpha_3 + ...}}}$$. Für diese Darstellung gilt, dass falls $\alpha = \frac{p}{q} \in \mathbb{Q}$, dann konvergiert die CF Darstellung von $\alpha$ in $\mathcal{O}(\max\{\left|p\right|, \left|q\right|)\}$ vielen Schritten. Insbesondere ist $CF_n(\alpha) = \frac{p_n}{q_n}$ im Allgmeinen die beste Approximation von $\alpha$ mit Nenner $\leq q_n$.\\
		Auf das Ordnungsproblem angewandt, finden wir also $CF_k(\frac{l}{Q}) = \frac{p_k}{q_k}$ mit $q_k < N$, also $\frac{p_k}{q_k} = \frac{m}{r}$. Falls nun $ggT(m,r) = 1$, dann ist $r' = q_k$. Das ist aber nur ein Kandidat für $r$. An dieser Stelle kann getestet werden, ob $Y^{r'} \equiv 1 \mod N$. Falls nicht ist $r' \leq r$ und der Algorithmus kann wiederholt werden.
	\end{example}
	\section{Problem der verborgenen Untergruppe}
	\begin{definition}
		Eine Gruppe wird als $(G,\circ)$ notiert. Diese erfüllt Assoziativität, die Existenz eines neutralen Elements und die Existenz eines inversen Elements. Eine Untergruppe $H<G$ ist eine abgeschlossene Teilmenge.
	\end{definition}
	\begin{definition}[Graph Automorphie]
		Für einen Graphen $B = (V,E)$ sei $G$ die Menge der Automorphismen auf $G$. Dabei ist $f: V \to V$ bijektiv ein Automorphismus, wenn $\forall u,v \in V$ gilt $uv \in E$ genau dann, wenn $f(u)f(v) \in E$. $G$ ist auch eine Gruppe.
	\end{definition}
	\noindent Eine Untergruppe $H$ zerlegt $G$ in Nebenklassen $G = \bigcup_{g \in G} gH$ wobei $gH = \{gh : h \in H\}$.
	\begin{lemma}
		Sei $G$ eine Gruppe und $H<G$. $\forall g_1,g_2 \in G$ gilt $g_1H = g_2H \Leftrightarrow g_1^{-1}h_2 \in H$.
	\end{lemma}
	\begin{lemma}
		Sei $G$ eine endliche Gruppe, $H<G$. Dann haben alle Nebenklassen genau $\left|H\right|$ viele Elemente.
	\end{lemma}
	Mit diesen Informationen beschäftigen wir uns nun mit dem Problem der verborgenen Untergruppe.\\
	Gegeben sei eine endliche Gruppe $G$ und $f:G \to \{0,1\}^n$ mit einem Black-Box Schaltkreis. $f$ habe die Eigenschaft, dass eine Untergruppe $H$ existiere sodass \[\forall g \in G\; \forall h \in H\; f(g) = f(gh)\] $f$ ist also konstant in jeder Nebenklasse aber $\forall g_1 \neq g_2$ und $g_1H \neq g_2H$ soll \[f(g_1) \neq f(g_2)\] Die Aufgabe ist nun, $H$ zu finden.\\
	Man kann sehen, dass viele bereits bekannte Probleme auf das Problem der verborgenen Untergruppe zurückführbar sind.
	\begin{remark}[Simon]
		Hier ist gegeben $f:\{0,1\}^n \to \{0,1\}^n$ und $\exists a$ sodass $f(x) = f(x\oplus a)$. Man soll $a$ finden.\\
		Sei nun $G = \mathcal{F}_2^n$ mit der bitweisen Operation $\oplus$. $G$ ist eine Gruppe. Definiert man nun $H = \{0^n,a\}$, so ist $H$ eine Untergruppe und es gilt $f(gh) = f(g)$ für alle $h \in H$. Außerdem ist $G = x_1H \cup x_2H \cup ... \cup x_NH$ mit $x_i \neq x_j \oplus a$ für alle $i \neq j$. Es handelt sich also um ein Untergruppen Problem, das man lösen kann, wenn $H$ gefunden wird.
	\end{remark}
	\begin{remark}[Bernstein-Varizani]
		Gegeben ist $f:\{0,1\}^n \to \{0,1\}$ und es existiert ein $a$ sodass $f(x) = xa$. Die Aufgabe ist, $a$ zu finden.\\
		Wir definieren nun $G = \mathcal{F}_2^n$ wieder mit der bitweisen Paritätsfunktion $\oplus$. Wir definieren \[H = \{x \in \{0,1\}^n | x\bot a\} = \{x \in \{0,1\}^n | x\cdot a = 0\}\]
		$H$ ist eine Untergruppe und da $G$ endlich und $G = x_1H \cup x_2H \cup ... \cup x_NH$ gilt für jedes $x_i$: \[f(x_i\oplus h) = (x_i\oplus h)a = x_i \cdot a \oplus \underbrace{h \cdot a}_{=0} = f(x_i)\] Die andere Eigenschaft ist trivial auch erfüllt und damit ist auch dieses Problem auf das Untergruppenproblem rückführbar.
	\end{remark}
	\begin{remark}[Shor]
		Gegeben $Y,N$ mit $ggT(Y,N) = 1$. Finde $\min\{r|Y^r \equiv 1\}$.\\
		Wir definieren $G = (\mathbb{Z},+)$ mit der Addition als unsere Gruppe. Es sei $H = \{rm | m \in \mathbb{Z}\}$. Die Nebenklassen von $H$ sind dann $\mathbb{Z} = r\mathbb{Z} \cup 1+r\mathbb{Z} \cup ... \cup (r-1) + r\mathbb{Z}$. Außerdem sei $f_N(x) = Y^x\mod N$.\\
		Gilt $x \in a+r\mathbb{Z}$, dann ist $f(x) = f(a+rk) = Y^{a+rk}\mod N = Y^a \mod N \cdot\underbrace{ Y^{rk} \mod N}_{=1} = f(a)$. Andererseits für $a\neq b < r$ würde gelten, wenn $f(a) = f(b)$, dass \[Y^a \mod N = Y^b \mod N\] und damit wäre $Y^{a-b} = 1 \mod N$. Da man o.B.d.A. von $a > b$ ausgehen kann, gilt, dass $r = a-b < r$, was einen Widerspruch darstellt, oder dass $a=b$, was auch einen Widersprich darstellt. Also lässt sich auch dieses Problem auf das Untergruppenproblem reduzieren. 
	\end{remark}
	\begin{theorem}
		Ist $G$ abelsch, dann ist das HSP für $G$  in BQP.
	\end{theorem}
	\begin{lemma}
		Sei $G = (G\mathbb{F}_2^n, \oplus)$. Sei $H<G$ und $H^\bot = \{h \in G | g\cdot h = 0 \; \forall g \in G\}$.  Für $y \in G\mathbb{F}_2^n$ gilt \[\sum_{h \in H} (-1)^{hy} = \begin{cases}
			\left|H\right|, & y \in H^\bot\\
			0, & \text{ sonst}
		\end{cases}\]
	\end{lemma}
	Wir geben nun einen Algorithmus an, der ein Element aus $H^\bot$ findet. \[|0^n\rangle |0^n\rangle \overset{H}{\to} \frac{1}{\sqrt{2^n}} \sum_{x \in \{0,1\}^n} |x\rangle |0^n\rangle \overset{U_f}{\to} \frac{1}{\sqrt{2^n}}\sum_{x \in \{0,1\}^n} |x\rangle |f(x)\rangle\] Sei nun $T$ eine Menge mit einem Element aus jeder Nebenklasse von $H$. Dann gilt \[\left|T\right| = \frac{\left|G\right|}{\left|H\right|} = \frac{2^n}{\left|H\right|}\] Es gilt darum weiter \[\frac{1}{\sqrt{2^n}}\sum_{x \in \{0,1\}^n} |x\rangle |f(x)\rangle = \frac{1}{\sqrt{2^n}}\sum_{g \in T} \sum_{x \in H} |g\oplus x\rangle |f(g)\rangle \overset{H}{\to} \frac{1}{\sqrt{2^n}} \sum_{g \in T} \sum_{x \in H} \frac{1}{\sqrt{2}^n} \sum_{y \in \{0,1\}^n} (-1)^{(g\oplus x)y}|y\rangle |f(g)\rangle\]\[ = \frac{1}{2^n} \sum_{g \in T} \sum_{y \in \{0,1\}^n} (-1)^{gy}\sum_{x \in H} (-1)^xy|y\rangle|f(g)\rangle = \frac{\left|H\right|}{2^n} \sum_{g \in T} \sum_{y\in H^\bot} (-1)^{gy}|y\rangle |f(g)\rangle\]
	Nun wird auf dem ersten Qubit gemessen und man erhält $y \in H^\bot$ mit Wahrscheinlichkeit $$\sum_{g \in T} \left(\frac{\left|H\right|}{2^n} (-1)^{gy}\right)^2 = \sum_{g \in T} \frac{\left|H\right|^2}{2^{2n}} = \frac{\left|T\right| \left|H\right|^2}{2^{2n}} = \frac{\left|H\right|}{2^n}$$ Insbesondere können alle $y \in H1\bot$ mit der gleichen Wahrscheinlichkeit gemessen werden. Hat $H^\bot$ nun die Dimension $d$, messen wird $d$ Vektoren $y$ um \[\mathbb{P}[\text{alle Vektoren sind linear unabhängig}] \geq \frac{1}{4}\]
	\subsection{Graphenautomorphie Problem}
	Wir wissen bereits, dass sich dieses Problem als HSG Problem darstellen lässt. Allerdings unterscheidet sich die Formulierung von den meisten anderen insofern, dass die erzeugt Gruppe nicht abelsch ist.\\
	Formal definiert ist ein Automorphismus eine Abbildung $\phi: V \to V$ wobei $\forall u,v \in V$ gilt $(u,v) \in E \iff (\phi(u),\phi(v)) \in E$. Die Menge der Automorphismen ist eine Untergruppe der Menge der Permutationen auf $V$. Insbesondere kann ein $f: \{\text{Permutationen} \to \{0,1\}^n\}$ definiert werden, sodass $f(\phi) = \phi(G)$. Ist $\phi$ ein Automorphismus, dann gilt $\phi(G)=G$. Die Fragestellung kann nun formuliert werden als\\
	Gegeben $G$, existiert eine nicht-trivialer Automorphismus auf $V(G)$?\\
	Dieses Problem ist eng verwandt mit dem Graphisomorphismus Problem, denn $G$ und $H$ sind isomoprh $\iff \left|AUT(G\cup H)\right| = 2\left|AUT(G)\right|\left|AUT(H)\right|$.
	\section{Endliche Quantenautomaten}
	\begin{definition}[endlicher Automat]
		Ein klassischer Automat, genannt 1DFA ist gegeben als \[A = (Q, \Sigma, \delta, z_0, E)\] wobei \begin{itemize}
			\item $Q$ die Menge der Zustände
			\item $\Sigma$ das Alphabet
			\item $\delta : Q\times \Sigma \to Q$ die Überführungsfunktion
			\item $z_0$ der Anfangszustand
			\item und $E\subset Q$ die Menge der Endzustände ist
		\end{itemize}
		$\delta$ kann für ein $a \in \Sigma$ als Matrix beschrieben werden, durch \[(M_a)_{j,i} = \begin{cases}
			1, & \delta(q_i, a) = q_j\\
			0, & \text{ sonst}
		\end{cases}\]
		wobei $q_i, q_j$ Zustände in $Q$ seien. Diese können weiter als Vektoren geschrieben werden, wodurch $\delta$ mit einer Matrixmultiplikation dargestellt werden kann.\\
		Probabilistische Automaten verallgemeinern die 1DFA dadurch, dass ein Übergang beim Lesen eines Buchstabens $\sigma \in \Sigma$ mehrere Zustände annehmen kann. Jeder Übergang ist einer Wahrscheinlichkeit zugeordnet. In diesem Modell ist ein Zustand wieder ein Vektor, wobei die Komponenten jedem möglichen Zustand eine Wahrscheinlichkeit zuordnen. Ein Zustand für $Q = \{q_1,q_2\}$ der Form $\binom{1/2}{1/2}$ wäre also mit 50\%-iger Wahrscheinlichkeit $q_1$ und genauso $q_2$. Die Übergangsmatrix ist dann auch anders definiert:\\
		Es gilt $\delta(q_i,a,q_j) = \mathbb{P}[q_i \overset{a}{\to} q_j]$. Für $a \in \Sigma$ ist $(M_a)_{j,i} = \delta(q_i,a,q_j)$
	\end{definition}
	\begin{definition}
		Ein endlicher Quantenautomat, genannt 1QFA, ist definiert durch ein Tupel \[A = (Q,\Sigma,\delta,q_0,E_a,E_r)\] wobei \begin{itemize}
			\item $Q$ die Menge der Zustände,
			\item $\Sigma$ das Alphabet,
			\item $\delta$ die Übergangsfunktion,
			\item $q_0$ der Startzustand,
			\item $E_a$ die Menge der akzeptierenden Zustände,
			\item $E_r$ die Menge der verwerfenden Zustände ist.
		\end{itemize}
		Insbesondere muss als $E_a,E_r \subset Q$ mit $E_a \cap E_r = \varnothing$ gelten. $E_n = Q\setminus (E_a \cup E_r)$ ist de Menge der Messzustände. Wir definieren die Basiszustände $|q_i\rangle$ mit $q_i \in Q$. Möglich sind aber auch Quantenzustände $|q\rangle = \sum_{q_i \in Q} \alpha_i |q_i\rangle$ mit $\alpha_i \in \mathbb{C}$.  
		Weiter gilt $\delta: Q\times \Sigma \times Q \to \mathbb{C}$ mit $\delta(q_i,a,q_j)$ ist die Amplitude von $q_j$ im erreichten Quanten-Zustand. Damit ist für $a \in \Sigma$ \[(M_a){j,i} = \delta(q_i,a,q_j)\] und $M_a$ ist unitär. Einen Übergang kann man auch über einen linearen Operator $V_a$ definieren. Dabei ist \[V_a|q\rangle= \sum_{q' \in Q} \delta(q,a,q')|q'\angle\] wobei $\sum_{q' \in Q} \left|\delta(q,a,q')\right|^2 = 1$. Dafür wird $a$ aus dem Arbeitsalphabet $\Gamma = \Sigma \cup \{\#, \$\}$. Diese sind als Start- und Endbuchstaben gedacht und sind unabhängig von $\Sigma$.
	\end{definition}
	Wir führen nun ein, wie Messungen mit 1QFA funktionieren.
	\subsection{Messung nach Lesen von jedem Symbol}
	Es gilt $Q = E_a \cup E_r \cup E_n$. Ein Zustand $|\psi\rangle$ wird gemessen und man erreicht einen von drei Fällen. Ist das Ergebnis der Messung in $E_a$ wird akzeptiert und angehalten, ist es in $E_r$ wird verworfen und angehalten und ist das Ergebnis in $E_n$, so wird normiert und weiter gemacht.\\
	Sei $|\psi\rangle = \alpha_0 |q_0\angle + \alpha_1|q_1\rangle + \alpha_2|q_2\rangle + \alpha_3|q_3\rangle$ ein konkreter Zustand. Sei weiter $E_a = \{q_0\}, E_r = \{q_1\}, E_n = \{q_2,q_3\}$. Mit Wahrscheinlichkeit $\left|\alpha_0\right|^2$ wird akzeptiert, mit Wahrscheinlichkeit $\left|\alpha_1\right|^2$ wird verworfen und mit Wahrscheinlichkeit $\left|\alpha_2\right|^2 + \left|\alpha_3\right|^2$ wird weiter gerechnet. Der Folgezustand müsste im letzten Fall normiert werden und hat damit die Form \[(\alpha_2|q_2\rangle + \alpha_3|q_3\rangle)/\sqrt{\left|\alpha_2\right|^2 + \left|\alpha_3\right|^2}\]
	\subsection{Beschreibung der Berechnung}
	Wir betrachten Tupel der Form $(|\psi\rangle, p_a, p_r)$ vom Zustand und den bisherigen Halte-Wahrscheinlichkeiten. Am Anfang ist daher der Zustand $(|q_0\rangle, 0, 0)$. Lesen von $b \in \Sigma$ ist darstellbar als die Überführung zu \[(T_b|q_0\rangle,p_a,p_r)\]
	
	\begin{definition}
		Ein 1QFA $A$ akzeptiert $L\subset \Sigma^*$ mit Wahrscheinlichkeit $\frac{1}{2}+\varepsilon$, wenn \begin{enumerate}
			\item $x\in L$ impliziert, $\mathbb{P}(A \text{ akzeptiert}) \geq \frac{1}{2} + \varepsilon$, wobei $x = b_1b_2...b_n$ und damit \[T_\$T_{b_n}...T_{b_2}T_{b_1}T_\#(|q_0\rangle,0,0) = (|\psi\rangle, p_a, p_r)\] und damit $p_a \geq \frac{1}{2}+\varepsilon$ gelten muss. 
			\item $x\notin L$ impliziert $p_r \geq \frac{1}{2}+\varepsilon$.
		\end{enumerate}
	\end{definition}
	\begin{theorem}
		$1QFA \subsetneq REG$.
	\end{theorem}
	Die Frage ist nun, ob man Quantenautomaten stärker machen kann, um alle regulären Sprachen abzudecken.
	\subsection{Der Two-Way-Quanten-Automat}
	Wir beginnen zuerst mit dem klassischen Pendant.
	\begin{definition}[2DFA]
		Ein 2-DFA ist definiert wie ein 1DFA mit \[\delta: Q\times \Gamma \to Q\times \{L,N,R\}\] wobei $L,N,R$ die Richtungen der dazugehörigen Turingmaschine sind. Dieses Modell ist aber nicht stärker als die 1DFA. 
	\end{definition}
	\begin{definition}[2QFA]
		Sei $Q = \{q_0,...,q_n\}$. Im eindimensionalen Fall waren die Basiszustände definiert als $|q_i\rangle$. Im zweidimensionalen Fall sind die Basiszustände definiert durch $|q,i\rangle$ mit $q\in Q, \; i \in \{1,...,n\}$. $q$ ist dabei ein Zustand und $i$ eine Position im Eingabestring. Die Übergangsfunktion $\delta$ wird definiert durch \[\delta: Q \times \Gamma \times Q\times \{-1,0,1\} \to \mathbb{C}\]
		Die Funktion der 1QFA erfüllte auch die Orthogonalitätseingeschaft \[\delta(q_1,b,q')\delta(q_2,b,q')^* = \begin{cases}
			1, & q_1 = q_2\\
			0, & q_1\neq q_2
		\end{cases}\]
		Die Funktion für 2QFA muss die selbe Eigenschaft erfüllen.\\
		Wir zerlegen die Übergangsfunktion in zwei Teile. Der erste Teil kümmert sich um die Zustände und ist gleich definiert wie im Falle eines 1QFA. Die Richtung wird definiert durch \[D:Q\to \{-1,0,1\}\]
		Im Allgemeinen sei $D(q,i) = (q,i+d \mod n)$ für $d \in \{-1,0,1\}$. 
	\end{definition}
	\begin{theorem}
		Ein 2QFA kann nicht reguläre Sprachen erkennen. Es gilt \[1QFA \subsetneq REG \subsetneq 2QFA\]
	\end{theorem}
	\section{Quantenkommunikationskomplexität}
	\subsection{klassische Varianten}
	Die Komplexität wird hier nicht mehr anhand der Laufzeit gemessen, sondern daran, wie viel Information ausgetauscht werden muss. Wir betrachten die Kommunikation zwischen zwei Parteien A und B. Seien $X,Y \subseteq \{0,1\}^n$. Es sei $f:X\times Y \to \{0,1\}$. Wir nehmen an, A habe die Information $x$ und B habe $y$. Nun ist die Frage, wie viele Bits ausgetauscht werden müssen, damit A und B $f$ berechnen können.
	\begin{example}
		\begin{enumerate}
			\item Seien $X=Y=\{0,1\}^n$ und $f(x,y) = \bigoplus_{i=1}^n x_i \oplus \bigoplus_{j=1} y_j$. Soll nun A de Lösung kennen, so müsste nur ein Bit von B nach A geschickt werden. Wenn B die Information $\bigoplus_{j=1} y_j$ nach A schickt, so kann A $f$ berechnen.
			\item Sei $g_2(x,y) = \begin{cases}
				1, & \left|x\right|_1 = \left|y\right|_1\\
				0, & \text{ sonst}
			\end{cases}$ Im Worst-Case sind nun alle $y_j = 1$. Dann müsste B $\lceil\log(\left|y\right|_1)\rceil$ Bits zu A schicken.
			\item Sei $f_3(x,y) = \begin{cases}
				1, & x=y\\
				0, & \text{ sonst }
			\end{cases}$. In diesem Fall sind $n$ Bits ausreichend und notwendig.
			Wir zeigen wir nun, dass $n$ Bits notwendig sind?\\
			Es muss ein Kommunikationsprotokoll vorab vereinbaren, das beide Parteien kennen. Dieses Protokoll lässt sich im Allgemeinen als Spielbaum darstellen, wobei die die Baumtiefe der Menge an zu versendenden Bits entspricht. Außerdem gibt es $\forall (x,y) \in X\times Y$ einen Pfad im Baum. Daher kann man sehen, dass falls die Kommunikationskomplexität $\leq n-1$ ist, dann $\exists w_1\neq w_2 \in X=Y$ mit Pfad($w_1w_1$) = Pfad($w_2w_w$) = Pfad($w_1w_2$), da der Teilpfad bis zum Ende von $w_1$ dem Teilpfad bis zum Ende von $w_2$ entspricht. Das geht weiter, wenn anschließend das Wort $w_2$ gelesen wird. Das ist aber ein Widerspruch, da $w_1\neq w_2$ und daher Pfad($w_1w_2$) in einer 0 endet, die anderen beiden Pfade hingegen in einer 1.
		\end{enumerate}
	\end{example}
	\subsection{probabilistische Varianten}
	Hier sind wir auf der Suche nach Protokollen, sodass A berechnet $f(x,y)$ mit Fehlerwahrscheinlichkeit $\leq \varepsilon$. Für ein Problem $P$ bezeichnen wir mit $C_\varepsilon(P)$ die Kommunikationskomplexität von $P$ mit Fehlerwahrscheinlichkeit $\leq \varepsilon$, wobei $C(P)=C_0(P)$ die deterministischen Kommunikationskomplexität.
	\begin{example}
		Wir arbeiten weiter mit der Funktion $f_3 = EQ$ vom obigen Beispiel und möchten die Fehlerwahrscheinlichkeit $\leq \varepsilon$ halten. Dafür lassen wir A und B die kleinste Primzahl $p$ berechnen, sodass $p>\frac{n}{\varepsilon}$. Die folgenden Berechnungen finden statt in $\mathbb{Z}_p$. B bestimmt mit den Bits von $y$ ein Polynom $q$ der Form \[q(z) = y_1+y_2z+y_3z^2 + ... + y_nz^{n-1}\] und wählt ein zufälliges $v \in_R \mathbb{Z}_p$ und berechnet $q(v) = w$. Anschließend werden $v$ und $w$ an A geschickt. A berechnet daraufhin das Polynom \[P(z) = x_1+x_2z+x_3z^2 + ... + x_nz^{n-1}\] Wenn $P(v) = w$, dann wird $1$ als Antwort zurückgegeben, andernfalls 0. Aus der Zahlentheorie wissen wir, dass $p\leq \frac{2n}{\varepsilon}$, weswegen der Algorithmus nur $2\lceil\log(\frac{2n}{\varepsilon})\rceil = \mathcal{O}(\log n)$ Bits verschickt. Es fehlt nun noch zu zeigen, dass die Fehlerwahrscheinlichkeit in der Tat $\leq \varepsilon$ ist. Wenn $P(v)\neq w$ ist, dann ist die Antwort $0$ gerechtfertigt, da $x\neq y$ sein müssen. Wenn allerdings 1 zurückgegeben wird, dann könnte es trotzdem sein, dass $x\neq y$ obwohl $P(v) = q(v)$. Es gilt aber \[\mathbb{P}_v[q(v)=P(v) | q\neq P] = \mathbb{P}_v[q(v)-P(v)=0|q\neq P] = \mathbb{P}_v[v \text{ ist NST von } q-P]\] Der Grad von $q-P$ ist höchstens $n-1$ und daher ist die Anzahl der Nullstellen $\leq n-1$. Daher ist obige Wahrscheinlichkeit \[\leq \frac{n-1}{p} \leq \frac{n}{\frac{n}{\varepsilon}} \leq \varepsilon\]
	\end{example} 
	\subsection{Quantenkommunikationskomplexität}
	Für Quantenkommunikation gibt es zwei verschiedene Varianten: \begin{definition}
		\begin{itemize}
			\item A und B schicken sich klassische Bits und dürfen nur vor dem Spiel Quantenzustände kommunizieren und verschränken
			\item Die Spieler dürfen Qbits übertragen
		\end{itemize}
	\end{definition}
	Man kann zeigen, dass beide Modelle gleichmächtig sind. Wie beginnen mit einem Beispiel für die zweite Variante.
	\begin{example}
		Diesmal betrachten wir drei Spieler A,B,C mit $x_A, x_B, x_C \in \{0,1\}$, sodass \[x_A \oplus x_B \oplus x_C = 0\] Die Aufgabe an die drei Spieler ist, drei Bits $a,b,c$ zu produzieren, sodass \[a\oplus b\oplus c = x_A \lor x_B \lor x_C\] Klassisch ist das nicht möglich zu lösen. Wir bezeichnen (für alle Spieler, aber am Beispiel von A) $a_i$ als das Bit, das A produziert, falls $x_A = i \in \{0,1\}$. Es gibt nun vier Fälle \[a_0 \oplus b_0 \oplus c_0 = 0\]
		\[a_0 \oplus b_1 \oplus c_1 = 1\] \[a_1 \oplus b_0 \oplus c_1 = 1\] \[a_1 \oplus b_1 \oplus c_0 = 1\] Hieran sieht man, dass dieses Problem deterministisch nicht lösbar ist. Auch eine probabilistische Lösung kann keine niedrige Fehlerwahrscheinlichkeit erreichen, da immer nur 3 der obigen Gleichungen gleichzeitig wahr sein können. Wir betrachten daher im Folgenden die Quantenlösung.\\
		Die Spieler teilen initial das Qbit \[|\phi\rangle = \frac{-1}{2}(|000\rangle - |011\rangle - |101\rangle - |110\rangle)\] den sogenannten GHZ Zustand. Jeder der Spieler (am Beispiel von A) führt anschließend folgendes Protokoll aus: Falls $x_A = 0$, Messung von $<\phi\rangle$ bezüglich der Standardbasis. Falls $x_A = 1$, eine Messung bezüglich der Basis $\{|+\rangle = \frac{1}{\sqrt{2}}(|0\rangle+|1\rangle), |-\rangle = \frac{1}{\sqrt{2}} |0\rangle-|1\rangle\}$. Anschließend setzt A den Wert $a$ auf das Ergebnis der Messung. Nun gibt es zwei Fälle \begin{enumerate}
			\item Fall: $(x_A,x_B,x_C) = (0,0,0)$. In diesem Fall ist es egal, welches Ergebnis die Messung zurückgibt, denn die Summe ist immer 0.
			\item Fall: $(x_A,x_B,x_C) \neq (0,0,0)$. In diesem Fall messen zwei der Spieler bezüglich der Dualbasis. Wenn man $|\phi\rangle$ bezüglich dieser Basis umschreibt, so erhält man \[|\phi\rangle = \frac{1}{4}(|+-0\rangle - |-+0\rangle - |++1\rangle + |--1\rangle)\]
			wodurch als Ergebnis nur $(0,1,0), (1,0,0), (0,0,1)$ oder $(1,1,1)$ zurückgegeben werden kann. Dieser erfüllen alle die Bedingung $a\oplus b\oplus c = x_A\lor x_B\lor x_C$.
		\end{enumerate}
	\end{example}
	\begin{example}
		Wir betrachten nun ein zweites Beispiel mit drei Spielern A,B,C und den Worten $x=x_1x_0, y=y_1y_0, z = z_1z_0$, wobei $x+y+z = 0 \mod 2$, $x_0\oplus y_0\oplus z_0 = 0$ und der zu berechnenden Funktion \[f(x,y,z) = \frac{x+y+z \mod 4}{2}\] d.h. \[f(x,y,z) = \begin{cases}
			0,& x+y+z=0\\
			1,& x+y+z=2
		\end{cases}\] Offensichtlich gilt $f(x,y,z) = x_1 \oplus y_1 \oplus z_1 \oplus (x_0 \oplus y_0 \oplus z_0)$. Alle drei Spieler sollen $f$ berechnen. Mit Quantenkommunikation sind 3 Bits notwendig, wobei ein deterministischer Ansatz 4 Bits benötigt.
	\end{example}
	\begin{definition}
		Wir geben einige Kommunikationsprobleme an, die später nützlich sein werden.\\
		\begin{enumerate}
			\item $Disj(x,y) = \lor_{i=1}^n x_i \land y_i$. Hier gilt $C_\varepsilon(Disj) = \Omega(n)$ und $C_0(Disj) = \Omega(n)$
			\item $EQ'(x,y) = \begin{cases}
				1, & x=y\\
				0, & \Delta(x,y) = \frac{n}{2}\\
				NaN, & \text{ sonst}
			\end{cases}$ wobei $\Delta$ der Hamming Abstand sei. Für dieses Problem gilt $C_\varepsilon(EQ') = \mathcal{O}(1)$, wenn gemeinsame Zufallsbits verwendet werden können. Wenn die Zufallsbits von A und B unabhängig sind, ist die Kommunikationskomplexität $\mathcal{O}(\log n)$. Es gilt immer $C_0(EQ') = \Omega(n)$. 
		\end{enumerate}
	\end{definition}
	\begin{definition}
		Für das Folgende ist ein bisschen Notation nötig. \[\mathcal{F}_n = \{f:\{0,1\}^n \to \{0,1\}\}\] Beachte, dass man anhand der Wahrheitstafel jedes $f$ als eine $2^n$-lange Bitfolge definieren kann. Da es $2^n = N$ viele solche $f$ gibt, ist \[\mathcal{F}_n \hat{=} \{0,1\}^N\]
		Auf diese Weise kann $L:\{0,1\}^2 \to \{0,1\}$ ausgebaut werden zu \[L(g,h): \{0,1\}^{n} \to \{0,1\}\] durch \[\forall x \in {0,1}^n\; L(g,h)(x) = L(g(x),h(x)) \; \forall g,h \in \mathcal{F}\] 
	\end{definition}
	\begin{theorem}
		Sei $F: \mathcal{F}_n \to \{0,1\}$ und $L:\{0,1\}^2 \to \{0,1\}$. Falls es einen Quanten-Algorithmus für $F(f)$ mit $t$ Fragen an $f$ der Form \[|x\rangle|y\rangle \to |x\rangle|y\oplus f(x)\rangle\] gibt, dann gibt es ein Quantenkommunikationsprotokoll mit $t(2n+4)$ Qubits für folgendes Problem:\\
		A erhält $g$, B erhält $h$ und A muss $F(L(g,h))$ berechnen.
	\end{theorem}
	\begin{example}
		Sei $F = OR_N$ und $L = AND_2$. Was ist $F(L(g,h))$? Es gilt \[F(L(g,h)) = 1 \Leftrightarrow \; \exists x \in \{0,1\}^n: L(g,h)(x) = 1\]
		Das wiederum ist genau dann der Fall, wenn es ein $x$ gibt, sodass $g(x)\land h(x) = 1$. Man sieht, dass diese Funktion äquivalent zum $Disj$ Problem ist, $F(L(g,h)) = Disj_N(g,h)$.\\
		Der Algorithmus von Grover kann auf natürliche Weise verwendet werden, um $OR_N$ zu berechnen (denn man sucht nach einer 1). Das bedeutet, es gibt einen Quantenalgorithmus für $F(f)$ mit $\mathcal{O}(\sqrt{N})$ Fragen. Aus obigem Theorem schließen wir, dass es ein Quantenkommunikationsprotokoll mit $\mathcal{O}(\sqrt{N}\log N)$ Bits gibt.
	\end{example}
	\begin{example}
		Sei $F=OR'$, das heißt \[F(f) = \begin{cases}
			1, & \left|\{x: f(x) = 0\}\right| = \left|\{x: f(x) = 1\}\right|\\
			0, & f(x) = 0\; \forall x\\
			NaN, & \text{ sonst}
		\end{cases}\] und sei $L=\oplus$. Wir stellen uns wieder die Frage, was $F(L(g,h))$ ist. \[F(L(g,h)) = 0 \Leftarrow g(x)\oplus h(x) = 0 \; \forall x \Leftrightarrow g(x)=h(x) \; \forall x \Leftrightarrow \Delta(g,h) = 0\] Auf der anderen Seite ist \[\Delta(g,h) = \frac{N}{2} \Leftrightarrow \left|\{x: L(g,h)(x) = 0\}\right| = \left|\{x: L(g,h)(x) = 1\}\right|\] Es folgt daraus $F(L(g,h)) = \lnot EQ'$, denn \[F(L(g,h)) = \begin{cases}
		1, & \Delta(g,h) = 2^{n-1}\\
		0, & \Delta(g,h) = 0\\
		NaN, & \text{ sonst}
	\end{cases}\]
	Da die Komplexität für das negierte Problem aber gleich bleibt, können wir aus einer Lösung für $F(L(g,h))$ auch auf $EQ'$ schließen. Der Algorithmus von Deutsch-Josza berechnet genau $F$ mit $t=1$. Hier wird anstatt NaN aber ein zufälliges Bit zurückgegeben, was aber zu keinen Problemen führt. Wir folgern, dass wir für $\lnot EQ'$ (und damit für $EQ'$) eine Quantenkommunikationskomplexität von $\mathcal{O}(\log N)$ erreichen.
	\end{example}
	\subsection{Finger Printing}
	Finger Printing ist eine Verallgemeinerung von Hashing. Es wird eine große Struktur mittels einer Funktion auf eine viel kleinere Menge abgebildet. Wir wollen Finger Printing verwenden, um nochmals die Kommunikation für EQ zu lösen. Diesmal habe A das Wort $x$ und B das Wort $y$. Beide sollen nun gewisse Bits zu einem dritten Spieler C schicken, der entscheidet, ob $x=y$. Im deterministischen Fall bleibt eine Wort-Case Komplexität von $\mathcal{O}(n)$. Wir wissen bereits, das probabilistisch $\mathcal{O}(\log n)$ Bits genügen, wenn gemeinsame Zufallsbits erlaubt sind. Wir führen eine Art von Code anhand seiner Eigenschaften ein, aber geben keine Implementierung an. Mit diesem Code lässt sich das EQ Problem noch effizienter lösen.
	\begin{definition}[Justesen Codes]
		Der Code ist gegeben durch eine Funktion \[E: \{0,1\}^, \to \{0,1\}^m\] wobei $m=cn$ für ein $c>2$. Der Code erfüllt die Eigenschaften \begin{enumerate}
			\item Ist $x=y$, dann $E(x)=E(y)$.
			\item Ist $x\neq y$, dann $\Delta(E(x),E(y)) \geq (1-\delta)m$ für ein $\delta \in (0,\frac{9}{10}+\frac{1}{15c})$ wobei $\Delta$ der Hammingabstand ist.
		\end{enumerate}
	\end{definition} 
	Mit diesem Code definieren wir nun ein Protokoll für die Funktion EQ.\\
	A und B haben Zugriff auf eine Zufallsfolge $i \in \{1,...,m\}$. Die Startzustände sind $x,y\in \{0,1\}^n$. A und B berechnen $E(x)$ bzw. $E(y)$ und wählen aus der Zufallsfolge ein gemeinsamen Index $i \in_r \{1,...,m\}$. Nun schicken beide Parteien das Bit $(E(x))_i$ bzw. $(E(y))_i$ an C. Sind die Werte gleich, gibt C 1 aus und 0 sonst.\\
	Das Protokoll gibt auf jeden Fall richtig 0 aus, denn wenn $E(x)\neq E(y)$, dann ist auch $x\neq y$. Die Fehlerwahrscheinlichkeit ist demnach \[\mathbb{P}[(E(x))_i = (E(y))_i | x\neq y] = \frac{\delta m}{m} = \delta\] Wenn man nun den Fehler auf $\leq \varepsilon$ bekommen möchte, so kann man dieses Protokoll $k$-mal wiederholen. Soll dann geilten, dass $\delta^k \leq \varepsilon$, so erhält man eine Worst-Case Komplexität von $\mathcal{O}(\log \frac{1}{\varepsilon})$. Das Problem dieser Vorgehensweise liegt im Austausch der gemeinsamen Zufallsfolge. Wenn man diese vermeiden möchte, kann auf einen Quantenansatz zurückgegriffen werden.\\
	Hierbei ist die Idee, die Vektoren $x,y$ zu betrachten und mit einer Funktion $f$ den Zusammenhang $x\neq y \implies \langle f(x)|f(y)\rangle \approx 0$ zu erzeugen. Wie wir sehen werden, ist der Justesen Code eine gute Wahl für $f$. Durch $E$ erhalten wir also eine Transformation der Form \[x \mapsto |h_x\rangle = \frac{1}{\sqrt{m}} \sum_{i=1}^m |i\rangle |E(i)\rangle\] Nach den Eigenschaften von $E$ folgt \begin{itemize}
		\item $x=y\implies |h_x\rangle = |h_y\rangle \implies \langle h_x | h_y \rangle = 1$
		\item $x\neq y \implies \langle h_x |h_y \rangle \leq \delta$.
	\end{itemize}
	Wir halten fest, dass $|h_x\rangle$ und $|h_y\rangle$ Quantenzustände der Länge $\log m +1 = \mathcal{O}(\log n)$ Qubits sind. Beide Zustände werden nun an C geschickt, welcher mit einen dafür ausgelegten Schaltkreis bestimmt, ob $x=y$. Der Schaltkreis hat die drei Eingaben $|0^n\rangle$, $|\phi\rangle = |h_x\rangle$, $|\psi\rangle = |h_y\rangle$. Mit einer Hadamard Transformation auf den ersten $n$ Bits ergibt sich der Zustand \[\frac{1}{\sqrt{2}} ((|0\rangle+|1\rangle)|\phi\rangle|\psi\rangle)\] Anschließend wird ein kontrollierter Swap auf den letzten beiden Qubits mit dem ersten Qubit als Kontrollbit durchgeführt. Wir erreichen en Zustand \[\frac{1}{\sqrt{2}} (|0\rangle|\phi\rangle|\psi\rangle + |1\rangle |\psi\rangle |\phi\rangle)\] Auf den ersten $n$ Bits wird wieder eine Hadamard Transformation durchgeführt und wir erhalten den Zustand \[\frac{1}{2} (|0\rangle(|\phi\rangle|\psi\rangle + |\psi\rangle|\phi\rangle) + |1\rangle (|\psi\rangle |\phi\rangle - |\phi\rangle |\psi\rangle))\] Wir schreiben nun \[|\phi\rangle = \sum_i a_i|i\rangle, \; |\psi\rangle = \sum_i b_i |\i\rangle\] Dadurch lässt sich der letzte Teil schreiben als \[|\psi\rangle |\phi\rangle - |\phi\rangle |\psi\rangle = \sum_{i,j} (a_ib_j - a_jb_i)|i\rangle|j\rangle\] Die Wahrscheinlichkeit 1 zu messen, ist demnach \[\frac{1}{4} \sum_{i,j} \left|a_ib_j - a_jb_i\right|^2 = \frac{1}{2} (1-\langle\phi|\psi\rangle^2)\] Ist $x=y$, dann ist dieser Ausdruck 0 und man misst auf jeden Fall den Wert 0, ansonsten wird mit positiver Wahrscheinlichkeit 1 gemessen. Wenn eine Fehlerwahrscheinlichkeit von $\varepsilon$ erreicht werden soll, so muss dieses Vorgehen $\mathcal{O}(\log \frac{1}{\varepsilon})$ mal wiederholt werden.
	\subsection{Quantenkryptologie}
	Der Sender A (Alice) will eine Nachricht an den Empfänger B (Bob) schicken. Die Nachricht bezeichnen wir im Folgenden mit $m$. A hat eine Verschlüsselungsfunktion $f$ und B hat eine andere Funktion $g$. Beide haben Zugriff auf einen Schlüssel $k$. Wenn $g = f^{-1}$, ist das Problem gelöst.\\
	Der Schlüssel ist der Knackpunkt. Ein Beispiel für den Schlüssel $k$ ist zum Beispiel der sogenannte One-Time-Pad. Dabei ist $k$ eine Bitfolge und A berechnet die Funktion $f(m,k) = m\oplus k$, das Bitweise XOR. Anschließend berechnet B die Funktion $f(f(k,m)) = m$. Das Verfahren ist sicher, solange die Übertragung des Schlüssels nicht abgehört wurde. Dieses Problem lässt sich aber mit einem Quantenansatz lösen. Das Protokoll basiert darauf, dass A und B bemerken können, wenn die Information in $k$ abgehört wurde.\\
	Sei $\left|m\right| = n$. A führt zuerst die folgenden Schritte aus
	\begin{enumerate}
		\item wähle $a,b \in _R \{0,1\}^{4n}$
		\item for $i=1$ to $4n$ do
		\item $|q_i\rangle = \begin{cases}
			|a_i\rangle, & b_i=0\\
			H|a_i\rangle = \frac{1}{\sqrt{2}} (|0\rangle + (-1)^{a_i} |1\rangle), & b_i = 1
		\end{cases}$
	\item endfor
	\item schicke $|q_1\rangle ... |q_{4n}\rangle$
	\end{enumerate}
	Anschließend folgt B dem folgenden Protokoll 
	\begin{enumerate}
		\item wähle $c \in \{0,1\}^{4n}$
		\item for $i=1$ to $4n$ do
		\item falls $c_i = 0 \; \Rightarrow $ Messung von $|q_i\rangle$ bezüglich Standardbasis, sonst Messung bezüglich Hadamard Basis.
	\end{enumerate}
	Anschließend schickt A $b$ an B und B schickt $c$ an A.\\
	Sei $G = \{i | c_i = b_i\}$. Es gilt $\mathbb{E}[\left|G\right|] = 2n$. A und B können $G$ bestimmen. Nun wählt A eine Untermenge $G' \subset G$ mit $\left|G'\right| = n$ und schickt die Menge der Paare $\{(a_i,i) | i \in G'\}$ an B. B schickt die Menge der Paare $\{(q_i,i)| i \in G'\}$ an A. Ist $a_i = q_i$ für alle $i \in G'$, dann gilt die Verbindung als sicher und es kann vorgegangen werden wie oben. Gibt es ein $i \in G'$ mit $a_i \neq q_i$, so wurde die Kommunikation abgehört.\\
	Wenn eine dritte Person C nun die Kommunikation abgehört hätte, dann müsste sie die $|q_i\rangle$ messen. Da C aber die zufällige Bitfolge c nicht kennt, weiß C nicht nach welcher Basis gemessen werden muss. Für jedes Bit ergibt sich daher die Wahrscheinlichkeit $\frac{1}{2}$, dass die richtige Basis für jedes Bit gewählt wurde und damit die Wahrscheinlichkeit, dass C abhören kann, ohne bemerkt zu werden $\left(\frac{1}{2}\right)^n$. 
	\section{Quanten fehlerkorrigierende Codes}
	\subsection{klassische fehlerkorrigierende Codes}
	Die Idee von fehlerkorrigierenden Codes ist, dass man ein Codewort $c$ eines Codes $C$ versendet, und dieses Codewort durch etwaige Störungen in der Übertragung verändert werden kann. Ist $C$ fehlerkorrigierend, so kann das übertragene Wort wieder zurück zu $c$ überführen solange die Anzahl der Fehler nicht zu groß ist. Dieser Rückschluss auf das eigentliche Codewort geschieht zum Beispiel nach dem Maximum Likelihood Prinzip. Die wahrscheinliche einfachsten Codes sind der Form $C = \{0^n,1^n\}$ (genannt Wiederholungscodes). Diese sind $\lfloor\frac{n-1}{2}\rfloor$-fehlerkorrigierend. Ein anderes Beispiel sind Paritätscodes $C$, wobei für $c \in C$ immer gelten muss, dass $\left|c\right|_1$ ist gerade. Diese können keinen Fehler korrigieren.\\
	Beide obigen Beispiele sind Subklassen der Menge der linearen Codes. Für einen linearen Code $C$ gilt für alle $c,c'$, dass $c\oplus c' \in C$ gilt, das heißt $C$ ist ein Unterraum des Raumes der Vektoren. Insbesondere gibt es eine Basis $B = \{b_1,...,b_n\}$ für $C$. Die Matrix $M$ mit den $b_i$ in der $i$-ten Zeile heißt Generatormatrix für $C$. Das heißt für alle $w \in \{0,1\}^n$ ist $M\cdot w$ ein Codewort in $C$. Eine Prüfmatrix $P$ ist eine boole'sche Matrix, sodass die Spalten eine Basis für $C^\bot$ definieren. Insbesondere gilt $c \in C \iff cP = 0$.
	\subsection{Quantencodes}
	Wir unterscheiden zwei verschiedene Fehler, die in einer Quantencode-Übertragung auftreten können: \begin{itemize}
		\item Bit-Flips: $a|0\rangle + b|1\rangle$ wird übertragen als $b|0\rangle + a|1\rangle$
		\item Phase-Flips: $a|0\rangle + b|1\rangle$ wird übertragen als $a|0\rangle - b|1\rangle$
	\end{itemize}
	\subsubsection{Bit-Flips}
	Mit einem einfachen Schaltkreis lassen sich die Transformationen $|0\rangle \to |000\rangle$ und $|1\rangle \to |111\rangle$ umsetzen. Damit erhält man $\phi \to \hat{\phi} = a|000\rangle + b|111\rangle$. Würde man nun nach einer fehlerhaften Übertragung $a|001\rangle + b|110\rangle$, so kann man mit dem Maximum-Likelihood-Prinzip wiederum das ursprüngliche Codewort rekonstruieren. Mit einem extra Register, kann man einen Schaltkreis erstellen, der die Positionen der Fehler ausgibt. Mithilfe eines NOT-Gatters auf diesen Bits können diese Fehler schließlich behoben werden.
	\subsubsection{Phase-Flip}
	Man bemerke, dass ein Phase-Flip nichts anderes ist, als ein Bit-Flip in der Dualbasis. Man transformiere das Fehlerhaft übertragene Qubit $a|0\rangle - b|1\rangle$ mit einer Hadamard Transformation und erhält \[\frac{1}{\sqrt{2}} (a-b)|0\rangle + (a+b)|1\rangle\] Wenn man darauf wiederum einen Bit-Flipm ausführt, so erhält man \[\frac{1}{\sqrt{2}} (a+b)|0\rangle + (a-b)|1\rangle\] Nun führe man wiederum eine Hadamard Transformation aus und man erhält dadurch $a|0\rangle + b|1\rangle$ zurück. Es ist nun klar, dass man den Schaltkreis von oben auf Phase-Flips anpassen kann.
	\subsubsection{9-Bit Code}
	Die Idee in diesem Code ist es, beide obigen Strategien kombiniert werden. Es wird zunächst ein Bit in neun Versionen davon kopiert. Der Code kann Fehler in irgendeinem der Qubits korrigieren. 
	\subsubsection{CSS Codes}
	Sei $H$ ein Unterraum von $\{0,1\}^n$. Die Codewörter sind Überlagerungen von den Vektoren in $H$. Wir definieren \[|H\rangle = \frac{1}{\sqrt{\left|H\right|}} \sum_{h \in H} |h\rangle\] Bit-Flips können mit einem $\{0,1\}$-Vektor $g$ repräsentiert werden. Es gilt $g_i = 1 \iff$ an Stelle $i$ ist ein Fehler. Es gilt \[|H+g\rangle = \frac{1}{\sqrt{\left|H\right|}} \sum_{h \in H} |h+g\rangle\] Für Phase.Flips verwenden wir einen Vektor $g'$ wobei \[|H+g'\rangle = \frac{1}{\sqrt{\left|H\right|}}\sum_{h \in H} (-1)^{g'\cdot h} |h\rangle\]
	Es folgt schließlich, wenn beide Fehler betrachtet werden sollen, dann ist \[|H+g+g'\rangle = \frac{1}{\sqrt{\left|H\right|}} \sum_{h \in H} (-1)^{g'\cdot h}|h+g\rangle\]
\end{document}